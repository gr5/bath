<!--
Improvements:
implement "50 fringes" button
Add sliders for fun
allow user to set lens diameter
how much rotation to get the 2 laser dots off of the F/11 test beam?
tan(cube_angle*4) = 1/(beamFnum*2)
  (cube angle*4 because if you rotate 1 deg Cw, test beam moves up by 2 deg and laser dots move down by 2 deg)
  (beamFnum*2 because you only have to move half the diameter of the test beam to be out of it)
  cube_angle = atan(1/(beamFnum*2))/4
version
0.6   Added CC license
0.7   Fixed bug with shear where returning red beam wasn't shifted also added defocus
0.8   Added ability to do larger diagram.  Fixed bug where you could click under a handle to move it
0.9   Fixed bug for when mirror is F/4 and diverger F.L. is 13mm
1.0   Added another focus point, f3; Added ability to rotate laser
1.1   Added better error handling when beams miss a component
1.2   Added class beam, refactored everything to use class beam, added ability for diverger to be in front of flat
1.3   Added ability to have diverger just below splitter
-->
<head>
<title>
Bath Interferometer web tool/diagrammer/calculator
</title>
</head>
<h2>Bath Interferometer web tool/diagrammer/calculator</h2>
(ver 1.3)<br>
F ratio of mirror under test:
<input type='text' size=3 value=3 onKeyUp=update() id='idFnum'>
&nbsp;&nbsp;&nbsp;&nbsp;

focal length of diverger(mm)
<input type='text' size=3 value=7 onKeyUp=update() id='idFL'>
<p>


size of splitter(mm):
<input type='text' size=3 value=15 onKeyUp=update() id='idSplitX'> 
<!-- <input type='text' size=3 value=15 onKeyUp=update() id='idSplitY'> -->
&nbsp;&nbsp;&nbsp;&nbsp;

Splitter rotation:
<input type='text' size=3 value=0 onKeyUp=update() id='idSplitRot'>
<font size=-1>
(even for F/2 mirror, 2 degrees is more than enough to get those 2 laser dots out of the test beam)
</font>
<br>
Distance from splitter center to diverger
<input type='text' size=20 value=12.5 onKeyUp=update() id='idDivergerDist'>
&nbsp;&nbsp;&nbsp;&nbsp;

Width of mirror/flat
<input type='text' size=3 value=10 onKeyUp=update() id='idFlatWidth'>
&nbsp;&nbsp;&nbsp;&nbsp;

Laser beam offset from splitter center
<input type='text' size=3 value=2 onKeyUp=update() id='idLaserX'>
&nbsp;&nbsp;&nbsp;&nbsp;

Laser beam rotation
<input type='text' size=3 value=0 onKeyUp=update() id='idLaserRotation'>

<br>
Laser beam width(mm)
<input type='text' size=3 value=2.6 onKeyUp=update() id='idLaserWidth'>


<br>
Splitter IOR
<input type='text' size=3 value=1.5 onKeyUp=update() id='idSplitterIOR'>

<br>
X Tilt: 
<input type='text' size=3 value=0 onKeyUp=update() id='idShear'>(Wyant waves)

<!-- <input type=button value='-50 fringes' onclick='fringes(-50)'>
<input type=button value='+50 fringes' onclick='fringes(50)'> -->
&nbsp;&nbsp;&nbsp;&nbsp;
<span id='idSpnFringes'></span>

<br>
Defocus: 
<input type='text' size=3 value=0 onKeyUp=update() id='idDefocus'> (Wyant waves)
&nbsp;&nbsp;&nbsp;&nbsp;
<span id='idSpnDefocus'></span>





<br>
Green dot is where to focus returning test beam when setting things up (temporarily lower bath so returning beam passes over splitter and flat) Formula is: <span id=green_formula>beam_separation_distance + diverger_focal_length behind diverger</span>
<br>
Yellow dot is CoC of mirror being tested.  Measure from here to mirror surface and divide by 2 to find focal length of mirror.  Formula for CoC position is: <span id=yellow_formula>beam_separation_distance/2 behind diverger</span>
<br>
<input type=checkbox id=idLarge onchange="update()"><label for="idLarge">Larger diagram and hide drag handles</label>
<br>
<input type=checkbox id=idF3 onchange="update()"><label for="idF3">virtual focal point of exiting beams left side</label>
<span id='idSpnF3'></span><br>
<input type=checkbox id=idLowerDiverger onchange="update()"><label for="idLowerDiverger">Move diverger to be in front of flat</label><br>
<input type=checkbox id=idLowerDiverger2 onchange="update()"><label for="idLowerDiverger2">Move diverger to be just below splitter</label><br>
<input type=checkbox id=idAutoFlat onchange="update()" CHECKED><label for="idAutoFlat">Automatically position flat</label>

<h2><font color='red'><span id=idError>Problems detected: none</span></font></h2>
<canvas id='idCanvas' width="1000" height="900" '></canvas>

<br>


<p xmlns:cc="http://creativecommons.org/ns#" >This work by <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="http://gr5.org">gr5</a> is licensed under <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a></p>



<script>

function max(a,b)
{
  return a>b?a:b;
}

function min(a,b)
{
  return a<b?a:b;
}

function avg(a,b)
{
    return (a+b)/2;
}

class coord
{
   constructor(_x, _y)
   {
       this.x=_x;
       this.y=_y;
   }
   
   copy()
   {
        return new coord(this.x,this.y);
   }
   
   rotate(center, angle)
   {
       // rotate ourself around "center" by said angle
       // first translate to 0,0 by subtracting center
       
       var x = this.x - center.x;
       var y = this.y - center.y;
       
       // now rotate by angle CCW
       
       this.x = x*Math.cos(angle) - y*Math.sin(angle);
       this.y = y*Math.cos(angle) + x*Math.sin(angle);
       
       // translate back again
       this.x += center.x;
       this.y += center.y;
   }
   
   add(vector)
   {
       this.x+=vector.x;
       this.y+=vector.y;
   }
   
   scale(scalar)
   {
     this.x*=scalar;
     this.y*=scalar;
   }
   
   magnitude()
   {
      // returns length of vector
      return Math.sqrt(this.x*this.x + this.y*this.y);
   }
   normalize()
   {
       this.scale(1/this.magnitude());
   }
   
   rotate90()
   {
        // for vectors
        var temp = this.x;
        this.x = -this.y
        this.y = temp;
   }
   rotate180()
   {
        this.x = -this.x;
        this.y = -this.y;
   }
   
   draw(_size, _color)
   {
        if (_size == null)
          _size = 0.05;
        if (_color==null)
          ctx.fillStyle="rgb(200,200,0)";
        else
          ctx.fillStyle=_color;
          
        ctx.beginPath();
        //moveto(this);
        
        arc(this.x,this.y, _size, 0, Math.PI*2,true);
        ctx.fill();      
   }
   
   lengthTo(_p2)
   {
       // find distance from this point to p2
       var a = this.x-_p2.x;
       var b = this.y-_p2.y;
       return Math.sqrt(a*a+b*b);// pythagarean theorem
   }
   
   average(p2)
   {
       // return new average point of current and point2
       return new coord(
            (this.x+p2.x)/2,
            (this.y+p2.y)/2   );
   }
   
}

class drag_handle
{
    constructor(){}
    place(_x,_y)
    {
        this.x=_x;
        this.y=_y;
        this.radius=.4;//mm
        this.clickRadius = this.radius*2;
    }
    draw()
    {
        if (bLarge)
            return;
        ctx.fillStyle="rgb(80,80,80)";
        ctx.fillRect( 
            (this.x-this.radius)*units_per_mm,
            (this.y-this.radius)*units_per_mm,
            (this.radius*2)*units_per_mm,
            (this.radius*2)*units_per_mm
            );
    }
    pointContained(_x,_y)
    {
      return (
          _x >= this.x-this.clickRadius &&
          _x <= this.x+this.clickRadius &&
          _y > this.y-this.clickRadius &&
          _y <= this.y+this.clickRadius
          );
    }
}


function create_handles()
{
    // diverger
    var h = new drag_handle();
    h.saveStart=function()
    {
      h.startVal = parseFloat(document.getElementById('idDivergerDist').value);
	  h.goodVal = h.startVal;
    }
    h.dragto=function(deltax,dy)
    {
	  var bDivergerBelowCube = document.getElementById('idLowerDiverger2').checked;
	  if (bDivergerBelowCube)deltax=dy;
      document.getElementById('idDivergerDist').value = h.startVal+deltax;
      update();
	  if (bError)
	  {
	    // go back to last good value
		document.getElementById('idDivergerDist').value = h.goodVal;
		var p = errorLocation;
		if (h.firstfail == null) h.firstfail = p;
		update();
		if (h.firstfail)
		  h.firstfail.draw(.3, "rgb(255,0,255)");
	  }
	  else
	  {
	    h.goodVal = h.startVal+deltax;
		h.firstfail=null;
	  }
    };
    drag_handles['diverger']=h;
    
    // laser
    var h = new drag_handle();
    h.saveStart=function()
    {
      h.startVal =  parseFloat(document.getElementById('idLaserX').value);
	  h.goodVal = h.startVal;
    }
    h.dragto=function(deltax,dy)
    {
      document.getElementById('idLaserX').value = h.startVal+deltax;
      update();
	  if (bError)
	  {
	    // go back to last good value
		document.getElementById('idLaserX').value = h.goodVal;
		var p = errorLocation;
		if (h.firstfail == null) h.firstfail = p;
		update();
		if (h.firstfail)
		  h.firstfail.draw(.3, "rgb(255,0,255)");
	  }
	  else
	  {
	    h.goodVal = h.startVal+deltax;
		h.firstfail=null;
	  }
    };
    drag_handles['laser']=h;
    
    // laser rotate
    var h = new drag_handle();
    h.saveStart=function()
    {
      h.startVal =  parseFloat(document.getElementById('idLaserRotation').value);
	  h.goodVal = h.startVal;
    }
    h.dragto=function(deltax,dy)
    {
      document.getElementById('idLaserRotation').value = h.startVal-deltax;
      update();
	  if (bError)
	  {
	    // go back to last good value
		document.getElementById('idLaserRotation').value = h.goodVal;
		var p = errorLocation;
		if (h.firstfail == null) h.firstfail = p;
		update();
		if (h.firstfail)
		  h.firstfail.draw(.3, "rgb(255,0,255)");
	  }
	  else
	  {
	    h.goodVal = h.startVal-deltax;
		h.firstfail=null;
	  }
    };
    drag_handles['laser_rot']=h;
    
    
    // cube
    var h = new drag_handle();
    h.saveStart=function()
    {
      h.startVal =  parseFloat(document.getElementById('idSplitRot').value);
	  h.goodVal = h.startVal;
    }
    h.dragto=function(dx,dy)
    {
      document.getElementById('idSplitRot').value = h.startVal+(dx+dy)*3;
      update();
	  if (bError)
	  {
	    // go back to last good value
		document.getElementById('idSplitRot').value = h.goodVal;
		var p = errorLocation;
		if (h.firstfail == null) h.firstfail = p;
		update();
		if (h.firstfail)
		  h.firstfail.draw(.3, "rgb(255,0,255)");
	  }
	  else
	  {
	    h.goodVal = h.startVal+(dx+dy)*3;
		h.firstfail=null;
	  }
    };
    drag_handles['cube']=h;
    
    // flat
    var h = new drag_handle();
    h.saveStart=function()
    {
      h.startX = drag_handles['flat'].defaultCenter.x;
      h.startY = drag_handles['flat'].defaultCenter.y;
      h.goodValX = h.startX;
	  h.goodValY = h.startY;
    }
    h.dragto=function(dx,dy)
    {
      drag_handles['flat'].flatCenter.x = drag_handles['flat'].defaultCenter.x+dx;
      drag_handles['flat'].flatCenter.y =  drag_handles['flat'].defaultCenter.y+dy;
      update();
	  if (bError)
	  {
	    // go back to last good value
		drag_handles['flat'].flatCenter.x = h.goodValX;
		drag_handles['flat'].flatCenter.y = h.goodValY;
		var p = errorLocation;
		if (h.firstfail == null) h.firstfail = p;
		update();
		if (h.firstfail)
		  h.firstfail.draw(.3, "rgb(255,0,255)");
	  }
	  else
	  {
	    h.goodValX = drag_handles['flat'].defaultCenter.x+dx;
	    h.goodValY = drag_handles['flat'].defaultCenter.y+dy;
		h.firstfail=null;
	  }
    };
    drag_handles['flat']=h;

    
    
    
    
    
    
}
class line
{
    constructor(_p1, _p2)
    {
        this.p1 = _p1;
        this.p2 = _p2;
    }
    intersection(line2) // returns a point (or false if parallel)
    {
       // https://www.geeksforgeeks.org/program-for-point-of-intersection-of-two-lines/
       var A = this.p1;
       var B = this.p2;
       var C = line2.p1;
       var D = line2.p2;
       var a1 = B.y - A.y;
       var b1 = A.x - B.x;
       var a2 = D.y - C.y;
       var b2 = C.x - D.x;
       var det = a1*b2 - a2*b1;
       if (det == 0)
       {
         // parallel
         var ret = new coord(0,0);
         ret.parallel = true;
         ret.contained = false;
         return ret;
       }
       var c1 = a1*A.x + b1*A.y;
       var c2 = a2*C.x + b2*C.y;
       var ret = new coord( (b2*c1 - b1*c2)/det,  (a1*c2 - a2*c1)/det);
       ret.bParallel=false;
       return ret;
    }
    
    isIntersectedPointWithin(p)
    {
	  // assumes p is on the line
      var smidge=0.01;//mm - if within 0.01mm
      return (
            p.x+smidge >= min(this.p1.x, this.p2.x) &&
            p.y+smidge >= min(this.p1.y, this.p2.y) &&
            p.x-smidge <= max(this.p1.x, this.p2.x) &&
            p.y-smidge <= max(this.p1.y, this.p2.y));
    }
    
    add(vector)
    {
      this.p1.add(vector);
      this.p2.add(vector);
    }
    
    draw()
    {
        ctx.beginPath();
        moveto(this.p1);
        lineto(this.p2);
        ctx.stroke();      
    }
    
    copy()
    {
        return new line(this.p1.copy(), this.p2.copy());
    }
    
    swap()
    {
        // swap p1, p2
        var t = this.p1;
        this.p1 = this.p2;
        this.p2 = t;
    }
    
    getVector()
    {
        // p2 minus p1 - returns coord
        return new coord(this.p2.x - this.p1.x, this.p2.y - this.p1.y);
    }
    
    distToPoint(p)
    {
        function sqr(x) { return x * x }
        function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) } // distance squared
        var v = this.p1;
        var w = this.p2;
        var l2 = dist2(v, w);
        if (l2 == 0) return Math.sqrt(dist2(p, v));
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.sqrt(
               dist2(p, { x: v.x + t * (w.x - v.x),
                          y: v.y + t * (w.y - v.y) }));
        
    }
    
}

class beam
{
    // consists of 2 lines
    constructor(_l1, _l2)
    {
        this.lines = Array(2);
        this.lines[0]=_l1;
        this.lines[1]=_l2;
    }
    draw()
    {
        for(i=0;i<2;i++)
            this.lines[i].draw();
    }
    
    swap()
    {
        // swap p1 and p2
        for(i=0;i<2;i++)
        {
            let temp_point = this.lines[i].p2;
            this.lines[i].p2 = this.lines[i].p1;
            this.lines[i].p1 = temp_point;
		}
    }
    
    setP2(p)
    {
        for(i=0;i<2;i++)
        {
            this.lines[i].p2 = p.copy();
        }
    }
    
    
    reflect(mirror)
    {
        // p2 must be at mirror
        let l1 = reflect(this.lines[0], mirror);
        let l2 = reflect(this.lines[1], mirror);
        return new beam(l1,l2)
    }

    swap()
	{
        // swap p1 and p2
        for(i=0;i<2;i++)
        {
            let temp_point = this.lines[i].p2;
			this.lines[i].p2 = this.lines[i].p1;
			this.lines[i].p1 = temp_point;
        }
	}

	shiftx(shift)
	{
		// move all 4 points in x direction
        for(i=0;i<2;i++)
        {
			this.lines[i].p1.x += shift;
			this.lines[i].p2.x += shift;
        }
	}
	
	shifty(shift)
	{
		// move all 4 points in y direction
        for(i=0;i<2;i++)
        {
			this.lines[i].p1.y += shift;
			this.lines[i].p2.y += shift;
        }
	}
	
    advance()
    {
        // p1 gets p2 and p2 continues farther along at same angle
        for(i=0;i<2;i++)
        {
            let temp_point = this.lines[i].p2.copy();
            this.lines[i].p2.x += (this.lines[i].p2.x - this.lines[i].p1.x);
            this.lines[i].p2.y += (this.lines[i].p2.y - this.lines[i].p1.y);
            this.lines[i].p1 = temp_point;
        }
      
    }
    
	focusPoint()
	{
		return this.lines[0].intersection(this.lines[1]);
	}
	
    intersect(l)
    {
      // intersects forward meaning p2 will be altered
      // intersects both lines in our beam with this line segment
      // returns null if successful, returns a point if part of the beam misses the line segment
     let error=null;
     for(i=0;i<2;i++)
     {
         let p = this.lines[i].intersection(l);
         this.lines[i].p2 = p;
         if (l.isIntersectedPointWithin(p) == false)
           error=p;
     }
     return error;
    }
    
    refract(l,ior1,ior2)
    {
        // refracts this beam across line l.  returns new beam.  
        //Beam p1 points must be in old medium and p2 must be on refraction line
        let l1=refract(this.lines[0], l, ior1, ior2);
        let l2=refract(this.lines[1], l, ior1, ior2);
        return new beam(l1,l2);
    }
    
    copy()
    {
        return new beam(this.lines[0].copy(), this.lines[1].copy());
    }
}


function reflectPointAcrossLine(l, pnt)
{
    // abc from here: https://math.stackexchange.com/questions/637922/how-can-i-find-coefficients-a-b-c-given-two-points
    // note that lower equations do ay+bx... but most people do ax+by...
    var b=l.p1.y - l.p2.y; // this is a on above link
    var a=l.p2.x - l.p1.x; // this is b on above link
    var c=l.p1.x*l.p2.y - l.p2.x * l.p1.y;
    
    // reflection from here: https://math.stackexchange.com/questions/1013230/how-to-find-coordinates-of-reflected-point
    
    var p=pnt.x;
    var q=pnt.y;
    
    var x=(p*(a*a-b*b)-2*b*(a*q+c)) / (a*a+b*b);
    var y=(q*(b*b-a*a)-2*a*(b*p+c)) / (a*a+b*b);
    
    return new coord(x,y);
}



function dotProduct(v1,v2)
{
    return v1.x*v2.x + v1.y*v2.y;
}

function refract(l, transitionLine, iorFrom, iorTo)
{
    // line (l) is the beam to be retracted and it needs to have p1 in old medium and p2 at transition line
    // a new line object is returned form this function.  Incoming variables are not modified
    
    // source: https://asawicki.info/news_1301_reflect_and_refract_functions.html
    
    var incidentVec = l.getVector();
    incidentVec.normalize();
    
    // get normal of surface
    var normal = transitionLine.getVector();
    normal.rotate90();
    normal.normalize();
    
    var eta = iorFrom/iorTo;
    var cosI = -dotProduct(normal,incidentVec);
    var k = 1-eta*eta*(1-cosI*cosI);
    if (k < 0)
    {
        // total internal reflection
        var p = l.p2.copy();
        var ret = new line(p,p);
        ret.tir=true;
    }
    
    incidentVec.scale(eta);
    normal.scale(eta*cosI+Math.sqrt(k));
    
    var p1 = l.p2.copy();
    var p2 = p1.copy();
    p2.add(incidentVec);
    p2.add(normal);
    var ret = new line(p1,p2);
    ret.tir=false;
    return ret;
}

function reflect(l,transitionLine)
{
    // line (l) will be modified and it needs to have p1 where beam comes from and p2 at reflection point
    var incidentVec = l.getVector();
    incidentVec.normalize();
    
    // get normal of surface
    var normal = transitionLine.getVector();
    normal.rotate90();
    normal.normalize();
    
    var scale_norm = -2*dotProduct(incidentVec, normal);
    normal.scale(scale_norm);
    normal.add(incidentVec);
    
    var p1 = l.p2.copy();
    var p2 = p1.copy();
    p2.add(normal);
    
    return new line(p1,p2);
}



function moveto(_coord, _y)
{
  if (_coord instanceof coord)
    ctx.moveTo(_coord.x*units_per_mm, _coord.y*units_per_mm);
  else
    ctx.moveTo(_coord*units_per_mm, _y*units_per_mm);
}

function lineto(_coord, _y)
{
  if (_coord instanceof coord)
    ctx.lineTo(_coord.x*units_per_mm, _coord.y*units_per_mm);
  else
    ctx.lineTo(_coord*units_per_mm, _y*units_per_mm);
}

function arcto(x1,y1,x2,y2,radius)
{
  ctx.arcTo(x1*units_per_mm,
            y1*units_per_mm,
            x2*units_per_mm,
            y2*units_per_mm,
            radius);
}

function arc(a,b,c,a1,a2,ccw)
{
    ctx.arc(a*units_per_mm,
            b*units_per_mm,
            c*units_per_mm,
            a1,a2,ccw);
}

var bError = false;
var errorLocation = null;

function error(str, p)
{

  document.getElementById('idError').innerHTML+=str+"<br>";
  if (p)
  {
      p.draw(.3, "rgb(255,0,255)");
	  errorLocation=p.copy();
  }
  bError=true;
}

function fringes(n)
{
  var fnum = parseFloat(document.getElementById('idFnum').value);
  var lambda = .000655; // 655nm
  document.getElementById('idShear').value = n;// * lambda * fnum;
  update();
}

function pointInsideSplitter(p)
{
	var horizontalLine = new line(p, new coord(p.x+1,p.y));
	var verticalLine = new line(p, new coord(p.x,p.y+1));
	var p2 = horizontalLine.intersection(splitter.right);
	if (p2.x < p.x) return false;
	p2 = horizontalLine.intersection(splitter.left);
	if (p2.x > p.x) return false;
	p2 = verticalLine.intersection(splitter.top);
	if (p2.y > p.y) return false;
	p2 = verticalLine.intersection(splitter.bottom);
	if (p2.y < p.y) return false;
	return true;
}



var drag_handles={};
var units_per_mm=1; // will set the scaling for all drawing.  "units" are canvas units.  Can be non integers like 1.23
var t_can;
var ctx;
var c_size;
var splitter={}; // contains: unit, tl (topleft),tr,bl,br,W (width),H,center, angle (cw rotation)
                 // also lines: top,bottom,left,right,diagonal
var lens={};
var laser={};
var refbeam={};
var testBeam={};

var diverger=new line(new coord(0,0), new coord(0,0)); // also: center
var flat=new line(new coord(0,0), new coord(0,0)); // also: center
var coRefBeamBlue ="rgb(80,80,255)";
var coTestBeamRed ="rgb(255,0,0)";
var bLarge;

var offsetX;
var offsetY;

function colorRefBlue()
{
    ctx.strokeStyle=coRefBeamBlue;
}

function colorTestRed()
{
    ctx.strokeStyle=coTestBeamRed;
}



var dragging = null;
var drag_start_x=0;
var drag_start_y=0;
function myDown(e){


    // get the current mouse position
    var mx;
    var my;    
    
    var t_can = document.getElementById('idCanvas');
    var BB=t_can.getBoundingClientRect();
    var offsetX=BB.left;
    var offsetY=BB.top;    
    
    if (e.touches)
    {
        if (e.touches.length > 1)
            return; // otherwise pinch zoom can hit a handle
        mx=parseInt(e.touches[0].clientX-offsetX)/units_per_mm;
        my=parseInt(e.touches[0].clientY-offsetY)/units_per_mm;
    }
    else
    {
        mx=parseInt(e.clientX-offsetX)/units_per_mm;
        my=parseInt(e.clientY-offsetY)/units_per_mm;
    }
    //alert(""+mx+" "+my);
    
    // loop through all the drag handles to see if we are clicking on one of them
    for (var key in drag_handles)
    {
        if ( (drag_handles[key] instanceof drag_handle) == false)
            continue;
        var h = drag_handles[key];
        if (h.pointContained(mx, my) == false)
            continue;
        // FOUND ONE!
        dragging = h;
        drag_start_x = mx;
        drag_start_y = my;
        h.saveStart();
        // tell the browser we're handling this mouse event
        e.preventDefault();
        e.stopPropagation();

        return;
    }
    dragging=null; // nothing found.  Not dragging.
    
    // debugging: add a dot to the scree at this spot
    //var p = new coord(mx,my);
    //p.draw();
}

function myUp(e){
    if (dragging === null) return;
    // tell the browser we're handling this mouse event
    //e.preventDefault();
    //e.stopPropagation();
    dragging = null;
}

// handle mouse moves
function myMove(e){
    // if we're dragging anything...
    if (dragging === null) return;

    // tell the browser we're handling this mouse event
    e.preventDefault();
    e.stopPropagation();

    // get the current mouse position
    var mx;
    var my;    
    var t_can = document.getElementById('idCanvas');
    var BB=t_can.getBoundingClientRect();
    var offsetX=BB.left;
    var offsetY=BB.top;    
    if (e.touches)
    {
        mx=parseInt(e.touches[0].clientX-offsetX)/units_per_mm;
        my=parseInt(e.touches[0].clientY-offsetY)/units_per_mm;
    }
    else
    {
        mx=parseInt(e.clientX-offsetX)/units_per_mm;
        my=parseInt(e.clientY-offsetY)/units_per_mm;
    }

    // calculate the distance the mouse has moved
    // since mouse down
    var dx=mx-drag_start_x;
    var dy=my-drag_start_y;
    dragging.dragto(dx,dy);
}

function update()
{
	bError=false;
	errorLocation = null;
    document.getElementById('idError').innerHTML="";
    var t_can = document.getElementById('idCanvas');
    bLarge = document.getElementById('idLarge').checked;
    bF3 = document.getElementById('idF3').checked;
    bAutoFlat = document.getElementById('idAutoFlat').checked;
	var bDivergerAtCube = !document.getElementById('idLowerDiverger').checked; // right of cube
	var bDivergerBelowCube = document.getElementById('idLowerDiverger2').checked;

    if (bLarge)
    {
        t_can.width=1700;
        t_can.height=1700;
    }
    else
    {
        t_can.width=1000;
        t_can.height=1000;
    }
    ctx = t_can.getContext('2d');
    splitter.W = parseInt(document.getElementById('idSplitX').value);
    splitter.H = splitter.W; //parseInt(document.getElementById('idSplitY').value);
    var splitterToDiverger = parseFloat(document.getElementById('idDivergerDist').value);
    splitter.angle = document.getElementById('idSplitRot').value*3.14159/180;
    
    var laserX = parseFloat(document.getElementById('idLaserX').value);
    var laser_rotation = parseFloat(document.getElementById('idLaserRotation').value)*3.14159/180;
    
    var laserW = parseFloat(document.getElementById('idLaserWidth').value);
    var IOR = parseFloat(document.getElementById('idSplitterIOR').value);
    var flatwidth = parseFloat(document.getElementById('idFlatWidth').value);
    diverger.fl = parseFloat(document.getElementById('idFL').value);
    var shear_waves = parseFloat(document.getElementById('idShear').value);
    if (isNaN(shear_waves)) shear_waves=0;
    var defocus = parseFloat(document.getElementById('idDefocus').value);
    if (isNaN(defocus)) defocus=0;
    
    var fnum = parseFloat(document.getElementById('idFnum').value);
    
    var BB=t_can.getBoundingClientRect();
    offsetX=BB.left;
    offsetY=BB.top;

    t_can.onmousedown = myDown;
    t_can.onmouseup = myUp;
    t_can.onmousemove = myMove;
    t_can.addEventListener("touchstart", myDown, false);    
    t_can.addEventListener("touchend", myUp, false);    
    t_can.addEventListener("touchmove", myMove, false);    
    
	var mirrorFocus2;
    var lambda = .000655; // 655nm
    var shear = shear_waves * lambda * fnum;
    // shear_waves = shear_distance / lambda / fnum
    // shear distance = shear waves * lambda * fnum
    // so only fnum matters and distance is proportional to fnum and smaller fnum is more difficult to position
    //document.getElementById('idSpnFringes').innerHTML = (shear / lambda / fnum).toFixed(0);
    
    // defocus however is much worse - fnum squared.  smaller fnum is harder to adjust defocus
    document.getElementById('idSpnFringes').innerHTML = "("+shear.toFixed(2)+"mm)";
    
    var defocus_mm = defocus*8*lambda*(fnum*2)*(fnum*2);
    document.getElementById('idSpnDefocus').innerHTML = "("+defocus_mm.toFixed(2)+"mm)";
	
if (bDivergerBelowCube)
	{
		// third way - diverger below cube and above flat
		document.getElementById('yellow_formula').innerHTML="diverger_to_cube_bottom_dist + beam_separation/2 left of cube right edge";
		document.getElementById('green_formula').innerHTML="diverger F.L. - diverger_to_cube_bottom_dist left of cube right edge";
	}
    else if (bDivergerAtCube)
	{
		// original way - Dale version
		document.getElementById('yellow_formula').innerHTML="beam_separation_distance/2 behind diverger";
		document.getElementById('green_formula').innerHTML="beam_separation_distance + diverger_focal_length behind diverger";
	}
    else
	{
		// Second way - worst way - stupidest way - diverger right of flat
		document.getElementById('yellow_formula').innerHTML="beam_separation_distance/2 in front of diverger";
		document.getElementById('green_formula').innerHTML="beam_separation_distance - diverger_focal_length in front of diverger";
	}
    
    canvas_width = t_can.clientWidth;
    canvas_height = t_can.clientHeight;
    c_size = min(canvas_width, canvas_height);
    
    splitter.unit = max(splitter.W,splitter.H);
    mm_width_needed = max(splitter.unit,9)*2.5 + splitterToDiverger;
    
    units_per_mm = canvas_height/mm_width_needed;
    
    // fill background color as black    
    ctx.fillStyle = 'rgb(0, 0, 0)';
    ctx.fillRect(0, 0, canvas_width, canvas_height);
            

    ctx.font = '30px sans';
    ctx.fillStyle="rgb(80,80,80)";
    ctx.fillText('Click and drag gray boxes!', 300, 35);


    
    splitter.center = new coord(splitter.unit*1, splitter.unit*1.2);
    splitter.tl = new coord(splitter.center.x - splitter.W/2, splitter.center.y - splitter.H/2);
    splitter.tr = new coord(splitter.center.x + splitter.W/2, splitter.center.y - splitter.H/2);
    splitter.bl = new coord(splitter.center.x - splitter.W/2, splitter.center.y + splitter.H/2);
    splitter.br = new coord(splitter.center.x + splitter.W/2, splitter.center.y + splitter.H/2);
    
    splitter.top = new line(splitter.tl,splitter.tr);
    splitter.left = new line(splitter.tl,splitter.bl);
    splitter.right = new line(splitter.br,splitter.tr);
    splitter.bottom = new line(splitter.bl,splitter.br);
    splitter.diagonal = new line(splitter.tl,splitter.br);
    
    splitter.dragHandle = new coord(splitter.tr.x+.7, splitter.tr.y-.7);
    
    // rotate splitter
    
    splitter.tl.rotate(splitter.center, splitter.angle);
    splitter.tr.rotate(splitter.center, splitter.angle);
    splitter.bl.rotate(splitter.center, splitter.angle);
    splitter.br.rotate(splitter.center, splitter.angle);
    splitter.dragHandle.rotate(splitter.center, splitter.angle);

    
    // draw splitter in white
    ctx.lineWidth=1;
    ctx.strokeStyle="rgb(255,255,255)";
    ctx.beginPath();
    moveto(splitter.tl);
    lineto(splitter.tr);
    lineto(splitter.br);
    lineto(splitter.bl);
    lineto(splitter.tl);
    lineto(splitter.br);
    ctx.stroke();  
    
    drag_handles['cube'].place(splitter.dragHandle.x, splitter.dragHandle.y);
    drag_handles['cube'].draw();    
    
    
    

    // diverger initial guess
	if (bDivergerBelowCube)
	{
		diverger.p1.y = splitter.center.y + splitterToDiverger;
		diverger.p1.x=0;
		diverger.p2 = diverger.p1.copy();
		diverger.p2.x=1;
	}
	else
	{
		diverger.p1.x = splitter.center.x + splitterToDiverger;
		diverger.p1.y=0;
		diverger.p2 = diverger.p1.copy();
		diverger.p2.y=1;
	}
	
	// clip line where lines stop on right side of display
	var clip_line = splitter.right.copy();
    clip_line.p1.x+=splitter.unit+splitterToDiverger-splitter.W/2;
    clip_line.p2.x+=splitter.unit+splitterToDiverger-splitter.W/2;
	
	
    
    //
    // calc and draw laser to cube
    //

    top_laser = min(splitter.tl.y, splitter.tr.y)-splitter.unit/4;
    x_center_laser = splitter.center.x + laserX;
	laser.start = new beam(
                           new line( new coord(x_center_laser - laserW/2, top_laser),
                                     new coord(x_center_laser - laserW/2, top_laser+1)),

                           new line( new coord(x_center_laser + laserW/2, top_laser),
                                     new coord(x_center_laser + laserW/2, top_laser+1)));

	for(i=0;i<2;i++)
		laser.start.lines[i].p1.rotate(laser.start.lines[i].p2, laser_rotation);
                               

    if (bLarge)
        ctx.font = '40px sans';
    else
        ctx.font = '20px sans';
    ctx.fillStyle="rgb(255,0,255)";
    var lx = splitter.center.x+laserX-1.5;
    var ly = top_laser-2;
    ctx.fillText('Laser', lx * units_per_mm, 
                          ly * units_per_mm);
    
    
    drag_handles['laser'].place(lx - 1, top_laser-2.5);
    drag_handles['laser'].draw();
    
    
    drag_handles['laser_rot'].place(lx + 3, ly+1);
    drag_handles['laser_rot'].draw();       
    
    // intersect these 2 lines with the cube top
	var p = laser.start.intersect(splitter.top);
    if (p !== null)
       error("laser missing cube",p);
    
    ctx.lineWidth=1;
    ctx.strokeStyle="rgb(255,0,255)";
    laser.start.draw();
    
    //
    // refract laser through cube
    //
    
	laser.incube = laser.start.refract(splitter.top,1,IOR);
    var p = laser.incube.intersect(splitter.diagonal)
	if (p !== null)
        error("laser missing diagonal",p);


    // draw laser in cube
	laser.incube.draw();
    
	if (bDivergerAtCube && !bDivergerBelowCube)
	{
		// diverger at cube
		// now do lower laser aka ref beam
		colorRefBlue();
		refbeam.lowercube = laser.incube.copy();
		refbeam.lowercube.advance();
		p = refbeam.lowercube.intersect(splitter.bottom);
		if (p != null)
			error("laser missing bottom of cube",p);
		refbeam.lowercube.draw();
		
		//
		// time to calculate and draw flat because above information is useful for positioning the flat
		//

		if (!bAutoFlat || (dragging !== null && dragging === drag_handles['flat']) )
		{
			// flat is being dragged!
			flat.center = drag_handles['flat'].flatCenter; // restore saved value
			flat.p1 = flat.center.copy();
			flat.p2 = flat.center.copy();
			flat.p1.x -= flatwidth*.3536; // sqrt(2)/4  or .707/2
			flat.p1.y -= flatwidth*.3536;    
			flat.p2.x += flatwidth*.3536;    
			flat.p2.y += flatwidth*.3536;
			flat.p1.rotate(flat.center, splitter.angle);
			flat.p2.rotate(flat.center, splitter.angle);        
		}
		else
		{
			
			flat.p1.x = refbeam.lowercube.lines[0].p2.x - 0.2; // .2mm left of where laser comes out of bottom of cube
			flat.p1.y = refbeam.lowercube.lines[0].p2.y + 0.2; // .2mm below where laser comes out of bottom of cube
			if (splitter.angle - laser_rotation < 0)
			{
				var adjust_y = Math.sin(laser_rotation-splitter.angle)*splitter.br.lengthTo(refbeam.lowercube.lines[0].p2); // move down a bit more so beam misses bot right corner of splitter         
				flat.p1.y += adjust_y;
				flat.p1.x -= adjust_y*Math.sin(laser_rotation-splitter.angle);
			}

			flat.p2 = flat.p1.copy();
			flat.p2.x += flatwidth*.7071; // assume 45 degrees initially
			flat.p2.y += flatwidth*.7071;
			flat.center = flat.p1.average(flat.p2);
			flat.center.rotate(flat.p1, splitter.angle);
			flat.p2.rotate(flat.p1, splitter.angle);
			drag_handles['flat'].defaultCenter = flat.center.copy();

			
		}
		ctx.strokeStyle="rgb(255,255,255)";
		
		flat.handle = new coord(flat.center.x-1.5, flat.center.y+1.5);
		flat.handle.rotate(flat.center, splitter.angle);
		drag_handles['flat'].place(flat.handle.x, flat.handle.y);
		drag_handles['flat'].draw();
		drag_handles['flat'].flatCenter = flat.center; // save this for later

		p = flat.intersection(splitter.bottom);
		if (flat.isIntersectedPointWithin(p))
			error("flat hits splitter",p);
		flat.draw();

		//
		// refract reference beam out bottom of splitter cube
		//

		colorRefBlue();
		
		refbeam.belowCube = refbeam.lowercube.refract(splitter.bottom, IOR, 1);
		p = refbeam.belowCube.intersect(flat)
		if (p!=null)
			error("ref beam misses flat",p);
		refbeam.belowCube.draw();

		// reflect refbeam off flat
		refbeam.rightOfFlat = refbeam.belowCube.reflect(flat);
		refbeam.rightOfFlat.intersect(clip_line);
		
		refbeam.rightOfFlat.draw();

		//
		// backing up, reflect test beam off diagonal (this helps us position diverger and clip line)
		//
		
		colorTestRed();
		
		testBeam.cubeRight = laser.incube.reflect(splitter.diagonal);
		p = testBeam.cubeRight.intersect(splitter.right);
		if (p!=null)
			error("test beam missing right side of cube",p);
		
		
		testBeam.cubeRight.draw();
		
		//
		// refract test beam out of cube to diverger
		//
		
		testBeam.toDiverger = testBeam.cubeRight.refract(splitter.right,IOR,1);
		testBeam.toDiverger.intersect(diverger);
		
		testBeam.toDiverger.draw();
		
		// 
		// now position and draw diverger    
		// 
		
		diverger.len=min(6,diverger.fl);
		diverger.center = new coord(diverger.p1.x, avg(testBeam.toDiverger.lines[0].p2.y, testBeam.toDiverger.lines[1].p2.y));
		diverger.p1 = diverger.center.copy();
		diverger.p2 = diverger.center.copy();
		diverger.p1.y -= diverger.len/2;
		diverger.p2.y += diverger.len/2;
		ctx.strokeStyle="rgb(255,255,255)";    
		diverger.draw();
		
		ctx.beginPath();
		var rad_center_offset = diverger.len*1.9; // also a fudge
		var angle = .25; // radians - this is a fudge
		moveto(diverger.p1.x, diverger.p1.y);
		arc(diverger.center.x-rad_center_offset, diverger.center.y, diverger.len*2, -angle,angle,false);
		arc(diverger.center.x+rad_center_offset, diverger.center.y, diverger.len*2, 
			 Math.PI-angle,Math.PI+angle,false);
		lineto(diverger.p1.x, diverger.p1.y);
		
		ctx.stroke();  
		
		drag_handles['diverger'].place(diverger.center.x, diverger.center.y - diverger.len*.75);
		drag_handles['diverger'].draw();


		if (pointInsideSplitter(diverger.p1))
			error("diverger inside splitter",diverger.p1);
		if (pointInsideSplitter(diverger.p2))
			error("diverger inside splitter",diverger.p2);

		p = diverger.intersection(flat);
		if (diverger.isIntersectedPointWithin(p))
			error("diverger hits flat",p);

		//
		// focus test beam through diverger
		//
		
		colorTestRed();

		var vector = testBeam.toDiverger.lines[0].getVector();
		vector.normalize();
		vector.scale(diverger.fl);
		testBeam.focus = diverger.center.copy();
		testBeam.focus.add(vector);
		
		testBeam.afterDiverger = testBeam.toDiverger.copy();
		testBeam.afterDiverger.advance();
		testBeam.afterDiverger.setP2(testBeam.focus);
		testBeam.afterDiverger.intersect(clip_line);
		testBeam.afterDiverger.draw();

		//
		// returning reference beam - draw right to left
		//
		
		colorRefBlue();
		refbeam.toDiverger = testBeam.toDiverger.copy();
		refbeam.toDiverger.intersect(clip_line);
		refbeam.toDiverger.swap();
		refbeam.toDiverger.intersect(diverger);
		refbeam.toDiverger.shifty(-shear);
		refbeam.toDiverger.draw();
		
		
		//
		// calculate focus point (not affected by shear)
		//
		
		vector.rotate180();
		vector.normalize();
		vector.scale(diverger.fl);
		var testBeamRightOfSplitterAngle = vector.copy(); // save for later
		refbeam.focus_before_refraction = diverger.center.copy();
		refbeam.focus_before_refraction.add(vector);
		
		//refbeam.focus_before_refraction.draw();
		
		// ref beam after diverger
		
		refbeam.afterDiverger = refbeam.toDiverger.copy();
		refbeam.afterDiverger.advance();
		refbeam.afterDiverger.setP2(refbeam.focus_before_refraction);
		p = refbeam.afterDiverger.intersect(splitter.right);
		if (p != null)
			error("returning reference beam missing right side of cube",p);
		refbeam.afterDiverger.draw();
		
		// refbeam in cube
		var splitter_right = splitter.right.copy();
		splitter_right.swap(); // refract function expects the points swapped - don't remember why
		refbeam.incube = refbeam.afterDiverger.refract(splitter_right, 1, IOR);
		p = refbeam.incube.intersect(splitter.left);
		if (p!=null)
			error("reference beam cone clipped within prism",p);
		refbeam.incube.draw();
		
		// refbeam left of cube
		refbeam.leftOfCube = refbeam.incube.refract(splitter.left, IOR, 1);
		
		// extend to left edge of drawing
		var clip_line_left = new line(new coord(2,0), new coord(2,1));
		refbeam.leftOfCube.intersect(clip_line_left);
		refbeam.leftOfCube.draw();
		
		//
		// testbeam returning from mirror
		//
		
		colorTestRed();
		
		// reflect focus point across splitter diagonal
		testBeam.focus_before_refraction = reflectPointAcrossLine(splitter.diagonal, refbeam.focus_before_refraction);
		// move by beam shear
		testBeam.focus_before_refraction.x -= shear;
		// also move by defocus
		testBeam.focus_before_refraction.y +=defocus_mm; // positive defocus means outside focus;
		
		// create beam with all 4 points at focus (before refraction) but soon will *end* at focus
		testBeam.justBelowCube = new beam(
			new line(testBeam.focus_before_refraction.copy(), testBeam.focus_before_refraction.copy()),
			new line(testBeam.focus_before_refraction.copy(), testBeam.focus_before_refraction.copy()));
		
		// adjust beam start to represent f/# of mirror being tested
		testBeam.fratio = fnum*2;
		testBeam.justBelowCube.lines[0].p1.x += 2;
		testBeam.justBelowCube.lines[1].p1.x -= 2;
		testBeam.justBelowCube.lines[0].p1.y += 4*testBeam.fratio;
		testBeam.justBelowCube.lines[1].p1.y += 4*testBeam.fratio;
		
		// rotate by same amount as laser
		for(i=0;i<2;i++)
			testBeam.justBelowCube.lines[i].p1.rotate(testBeam.justBelowCube.lines[i].p2, laser_rotation);

		// now intersect these beams with both the cube bottom and the flat.  It doesn't matter if the
		// focus is inside or outside the cube.  Before or after the diagonal.  The rest will just work!

		
		// intersect with bottom of cube
		testBeam.justBelowCube.intersect(splitter.bottom);

		// intersect with flat
		testBeam.justBelowCube.swap(); // now light aiming down (backwards temporarily)
		p = testBeam.justBelowCube.intersect(flat);
		if (p != null)
			error("returning test beam misses flat",p);


		testBeam.justBelowCube.draw();
		
		// reflect off flat backwards to the right
		testBeam.rightOfFlat = testBeam.justBelowCube.reflect(flat);
		testBeam.rightOfFlat.intersect(clip_line);
		testBeam.rightOfFlat.draw();

		// refract into cube
		testBeam.justBelowCube.swap(); // want this to point back up into the cube again
		splitter.bottom.swap();
		testBeam.lowerCube = testBeam.justBelowCube.refract(splitter.bottom,1,IOR);
		p = testBeam.lowerCube.intersect(splitter.diagonal);
		if (p!=null)
			error("returning test beam misses diagonal",p);
		
		testBeam.lowerCube.draw();
		
		// reflect off diagonal
		testBeam.leftCube = testBeam.lowerCube.reflect(splitter.diagonal);
		p = testBeam.leftCube.intersect(splitter.left);
		if (p!=null)
			error("returning test beam misses rear of splitter",p);
		testBeam.leftCube.draw();
		
		// refract out of cube
		testBeam.LeftOfCube = testBeam.leftCube.refract(splitter.left, IOR, 1);
		testBeam.LeftOfCube.intersect(clip_line_left);
		testBeam.LeftOfCube.draw();

		mirrorFocus2 = testBeam.rightOfFlat.focusPoint();
		mirrorFocus2.draw(0.1, "rgb(0,255,0)");
		
	}
	else if (bDivergerBelowCube==false)
	{
		// diverger at flat
		// continue test beam to bottom of cube
		colorTestRed();
		testBeam.lowerCube = laser.incube.copy();
		testBeam.lowerCube.advance();
		p = testBeam.lowerCube.intersect(splitter.bottom);
		if (p!=null) error("",p);
		testBeam.lowerCube.draw();
		
		
		//
		// FLAT
		//
		
		
		if (!bAutoFlat || (dragging !== null && dragging === drag_handles['flat']) )
		{
			// flat is being dragged!
			flat.center = drag_handles['flat'].flatCenter; // restore saved value
			flat.p1 = flat.center.copy();
			flat.p2 = flat.center.copy();
			flat.p1.x -= flatwidth*.3536; // sqrt(2)/4  or .707/2
			flat.p1.y -= flatwidth*.3536;    
			flat.p2.x += flatwidth*.3536;    
			flat.p2.y += flatwidth*.3536;
			flat.p1.rotate(flat.center, splitter.angle);
			flat.p2.rotate(flat.center, splitter.angle);        
		}
		else
		{
			
			flat.p1.x = testBeam.lowerCube.lines[0].p2.x - 0.2; // .2mm left of where laser comes out of bottom of cube
			flat.p1.y = testBeam.lowerCube.lines[0].p2.y + 0.2; // .2mm below where laser comes out of bottom of cube
			if (splitter.angle - laser_rotation < 0)
			{
				var adjust_y = Math.sin(laser_rotation-splitter.angle)*splitter.br.lengthTo(testBeam.lowerCube.lines[0].p2); // move down a bit more so beam misses bot right corner of splitter         
				flat.p1.y += adjust_y;
				flat.p1.x -= adjust_y*Math.sin(laser_rotation-splitter.angle);
			}

			flat.p2 = flat.p1.copy();
			flat.p2.x += flatwidth*.7071; // assume 45 degrees initially
			flat.p2.y += flatwidth*.7071;
			flat.center = flat.p1.average(flat.p2);
			flat.center.rotate(flat.p1, splitter.angle);
			flat.p2.rotate(flat.p1, splitter.angle);
			drag_handles['flat'].defaultCenter = flat.center.copy();

			
		}
		ctx.strokeStyle="rgb(255,255,255)";
		
		flat.handle = new coord(flat.center.x-1.5, flat.center.y+1.5);
		flat.handle.rotate(flat.center, splitter.angle);
		drag_handles['flat'].place(flat.handle.x, flat.handle.y);
		drag_handles['flat'].draw();
		drag_handles['flat'].flatCenter = flat.center; // save this for later

		p = flat.intersection(splitter.bottom);
		if (flat.isIntersectedPointWithin(p))
			error("flat hits splitter",p);
		
		flat.draw();
		
		//
		// test beam leaves cube
		//
		
		colorTestRed();
		testBeam.belowCube = testBeam.lowerCube.refract(splitter.bottom,IOR, 1);
		p = testBeam.belowCube.intersect(flat);
		if (p!=null) error("",p);
		testBeam.belowCube.draw();
		
		//
		// test beam reflects off flat
		//
		
		testBeam.leftOfDiverger = testBeam.belowCube.reflect(flat);
		testBeam.leftOfDiverger.intersect(diverger);
		testBeam.leftOfDiverger.draw();
		
		// 
		// now position and draw diverger    
		// 
		
		diverger.len=min(6,diverger.fl);
		diverger.center = new coord(diverger.p1.x, avg(testBeam.leftOfDiverger.lines[0].p2.y, testBeam.leftOfDiverger.lines[1].p2.y));
		diverger.p1 = diverger.center.copy();
		diverger.p2 = diverger.center.copy();
		diverger.p1.y -= diverger.len/2;
		diverger.p2.y += diverger.len/2;
		ctx.strokeStyle="rgb(255,255,255)";    
		diverger.draw();
		
		ctx.beginPath();
		var rad_center_offset = diverger.len*1.9; // also a fudge
		var angle = .25; // radians - this is a fudge
		moveto(diverger.p1.x, diverger.p1.y);
		arc(diverger.center.x-rad_center_offset, diverger.center.y, diverger.len*2, -angle,angle,false);
		arc(diverger.center.x+rad_center_offset, diverger.center.y, diverger.len*2, 
			 Math.PI-angle,Math.PI+angle,false);
		lineto(diverger.p1.x, diverger.p1.y);
		
		ctx.stroke();  
		
		drag_handles['diverger'].place(diverger.center.x, diverger.center.y - diverger.len*.75);
		drag_handles['diverger'].draw();


		if (pointInsideSplitter(diverger.p1))
			error("diverger inside splitter",diverger.p1);
		if (pointInsideSplitter(diverger.p2))
			error("diverger inside splitter",diverger.p2);

		p = diverger.intersection(flat);
		if (flat.isIntersectedPointWithin(p) && diverger.isIntersectedPointWithin(p))
			error("diverger hits flat",p);
		
		//
		// focus testbeam
		//
		
		colorTestRed();
		var vector = testBeam.leftOfDiverger.lines[0].getVector();
		vector.normalize();
		vector.scale(diverger.fl);
		testBeam.focus = diverger.center.copy();
		testBeam.focus.add(vector);
		
		testBeam.afterDiverger = testBeam.leftOfDiverger.copy();
		testBeam.afterDiverger.advance();
		testBeam.afterDiverger.setP2(testBeam.focus);
		testBeam.afterDiverger.intersect(clip_line);
		testBeam.afterDiverger.draw();		
		
		//
		// start refbeam off splitter
		//
		colorRefBlue();
		refbeam.cubeRight = laser.incube.reflect(splitter.diagonal);
		p = refbeam.cubeRight.intersect(splitter.right);
		if (p!=null) error("",p);
		refbeam.cubeRight.draw();
		
		//
		// refract refbeam out of splitter
		//
		
		refbeam.rightOfCube = refbeam.cubeRight.refract(splitter.right, IOR, 1);
		refbeam.rightOfCube.intersect(clip_line);
		refbeam.rightOfCube.draw();
		
		//
		// returning reference beam - draw right to left
		//
		
		colorRefBlue();
		refbeam.toDiverger = testBeam.leftOfDiverger.copy();
		refbeam.toDiverger.intersect(clip_line);
		refbeam.toDiverger.swap();
		refbeam.toDiverger.intersect(diverger);
		refbeam.toDiverger.shifty(-shear);
		refbeam.toDiverger.draw();
				
		//
		// calculate focus point (not affected by shear)
		//
		
		vector.rotate180();
		vector.normalize();
		vector.scale(diverger.fl);
		var testBeamRightOfSplitterAngle = vector.copy(); // save for later
		refbeam.focus_before_refraction = diverger.center.copy();
		refbeam.focus_before_refraction.add(vector);
		
		//
		// ref beam after diverger to flat
		//
		
		refbeam.afterDiverger = refbeam.toDiverger.copy();
		refbeam.afterDiverger.advance();
		refbeam.afterDiverger.setP2(refbeam.focus_before_refraction);
		p = refbeam.afterDiverger.intersect(flat);
		if (p != null)
			error("returning reference beam missing flat",p);
		refbeam.afterDiverger.draw();
		
		// ref beam above flat, below cube
		
		refbeam.aboveFlat = refbeam.afterDiverger.reflect(flat);
		p = refbeam.aboveFlat.intersect(splitter.bottom);
		if (p!=null) error("",p);
		refbeam.aboveFlat.draw();

		//
		// refbeam in cube
		//
		
		// lower cube
		splitter.bottom.swap(); // refract function expects the points swapped - don't remember why
		refbeam.lowerCube = refbeam.aboveFlat.refract(splitter.bottom, 1, IOR);
		p = refbeam.lowerCube.intersect(splitter.diagonal);
		if (p!=null)
			error("",p);
		refbeam.lowerCube.draw();
		
		// reflect refbeam off splitter diagonal
		refbeam.leftCube = refbeam.lowerCube.reflect(splitter.diagonal);
		p = refbeam.leftCube.intersect(splitter.left);
		if (p!=null) error("",p);
		refbeam.leftCube.draw();
		
		//
		// rebeam exits cube Left
		//
		
		refbeam.leftOfCube = refbeam.leftCube.refract(splitter.left, IOR, 1);
		// extend to left edge of drawing
		var clip_line_left = new line(new coord(2,0), new coord(2,1));		
		refbeam.leftOfCube.intersect(clip_line_left);
		refbeam.leftOfCube.draw();
		
		//
		// testbeam returning from mirror
		//
		
		colorTestRed();
		
		//
		// determine refbeam focus point
		//
		
		// we start with focus point of "ref beam above flat" - where those lines intersect if they didn't reflect off
		// flat or if there was no cube
		
		// reflect that focus point across splitter diagonal

		testBeam.focus_before_refraction = reflectPointAcrossLine(splitter.diagonal, refbeam.aboveFlat.focusPoint());
		// move by beam shear
		testBeam.focus_before_refraction.x -= shear;
		// also move by defocus
		testBeam.focus_before_refraction.x +=defocus_mm; // positive defocus means outside focus;
		
		// create beam with all 4 points at focus (before refraction) but soon will *end* at focus
		testBeam.rightOfCube = new beam(
			new line(testBeam.focus_before_refraction.copy(), testBeam.focus_before_refraction.copy()),
			new line(testBeam.focus_before_refraction.copy(), testBeam.focus_before_refraction.copy()));
		
		// adjust beam start to represent f/# of mirror being tested
		testBeam.fratio = fnum*2;
		testBeam.rightOfCube.lines[0].p1.x += 4*testBeam.fratio;
		testBeam.rightOfCube.lines[1].p1.x += 4*testBeam.fratio;
		testBeam.rightOfCube.lines[0].p1.y += 2;
		testBeam.rightOfCube.lines[1].p1.y -= 2;
		
		// rotate by same amount as laser
		for(i=0;i<2;i++)
			testBeam.rightOfCube.lines[i].p1.rotate(testBeam.rightOfCube.lines[i].p2, -laser_rotation + splitter.angle*2);

		// now intersect these beams with right of cube and clip_line
		
		testBeam.rightOfCube.swap();
		testBeam.rightOfCube.intersect(clip_line);
		testBeam.rightOfCube.swap();
		p = testBeam.rightOfCube.intersect(splitter.right);
		if (p!=null) error("",p);
		testBeam.rightOfCube.draw();
		
		//
		// refract test beam into cube
		//
		
		splitter.right.swap();
		testBeam.cubeRight = testBeam.rightOfCube.refract(splitter.right, 1, IOR);
		p = testBeam.cubeRight.intersect(splitter.left);
		if (p!=null) error("",p);
		testBeam.cubeRight.draw();
		
		//
		// refract test beam out of cube
		//
		
		testBeam.LeftOfCube = testBeam.cubeRight.refract(splitter.left, IOR, 1);
		testBeam.LeftOfCube.intersect(clip_line_left);
		testBeam.LeftOfCube.draw();

		mirrorFocus2 = testBeam.rightOfCube.focusPoint();
		mirrorFocus2.draw(0.1, "rgb(0,255,0)");
		
	}
	else
	{
		// diverger is just below splitter

		// continue test beam to bottom of cube
		colorTestRed();
		testBeam.lowerCube = laser.incube.copy();
		testBeam.lowerCube.advance();
		p = testBeam.lowerCube.intersect(splitter.bottom);
		if (p!=null) error("",p);
		testBeam.lowerCube.draw();		
		
		//
		// extend testBeam to diverger
		//
		
		colorTestRed();
		testBeam.belowCube = testBeam.lowerCube.refract(splitter.bottom,IOR, 1);
		testBeam.belowCube.intersect(diverger);
		// testBeam.belowCube.draw();  don't draw these lines until after diverger

		// 
		// now position and draw diverger    
		// 
		
		diverger.len=min(6,diverger.fl);
		diverger.center = new coord(avg(testBeam.belowCube.lines[0].p2.x, testBeam.belowCube.lines[1].p2.x), diverger.p1.y);
		diverger.p1 = diverger.center.copy();
		diverger.p2 = diverger.center.copy();
		diverger.p1.x -= diverger.len/2;
		diverger.p2.x += diverger.len/2;
		ctx.strokeStyle="rgb(255,255,255)";
		diverger.draw();
		
		ctx.beginPath();
		var rad_center_offset = diverger.len*1.9; // also a fudge
		var angle = .25; // radians - this is a fudge
		moveto(diverger.p2.x, diverger.p2.y);
		arc(diverger.center.x, diverger.center.y-rad_center_offset, diverger.len*2, Math.PI/2-angle,Math.PI/2+angle,false);
		arc(diverger.center.x, diverger.center.y+rad_center_offset, diverger.len*2, 
			 Math.PI*1.5-angle,Math.PI*1.5+angle,false);
		lineto(diverger.p2.x, diverger.p2.y);
		
		ctx.stroke();  
		
		drag_handles['diverger'].place(diverger.center.x - diverger.len*.75, diverger.center.y );
		drag_handles['diverger'].draw();


		if (pointInsideSplitter(diverger.p1))
			error("diverger inside splitter",diverger.p1);
		if (pointInsideSplitter(diverger.p2))
			error("diverger inside splitter",diverger.p2);
		
		
		//
		// redraw test beam up to diverger now that we have drawn the diverger
		//
		
		colorTestRed();
		p = testBeam.belowCube.intersect(diverger); // test intersection now that diverger is positioned
		if (p!=null) error("",p);
		testBeam.belowCube.draw();		
		
		//
		// POSITION AND DRAW FLAT
		//
		
		if (!bAutoFlat || (dragging !== null && dragging === drag_handles['flat']) )
		{
			// flat is being dragged!
			flat.center = drag_handles['flat'].flatCenter; // restore saved value
			flat.p1 = flat.center.copy();
			flat.p2 = flat.center.copy();
			flat.p1.x -= flatwidth*.3536; // sqrt(2)/4  or .707/2
			flat.p1.y -= flatwidth*.3536;    
			flat.p2.x += flatwidth*.3536;    
			flat.p2.y += flatwidth*.3536;
			flat.p1.rotate(flat.center, splitter.angle);
			flat.p2.rotate(flat.center, splitter.angle);        
		}
		else
		{
			
			flat.p1.x = testBeam.belowCube.lines[0].p2.x - 0.5; // .5mm left of where laser comes out of bottom of splitter
			flat.p1.y = testBeam.belowCube.lines[0].p2.y + 1; // 1mm below where laser comes out of bottom of splitter
			if (splitter.angle - laser_rotation < 0)
			{
				var adjust_y = Math.sin(laser_rotation-splitter.angle)*splitter.br.lengthTo(testBeam.lowerCube.lines[0].p2); // move down a bit more so beam misses bot right corner of splitter         
				flat.p1.y += adjust_y;
				flat.p1.x -= adjust_y*Math.sin(laser_rotation-splitter.angle);
			}

			flat.p2 = flat.p1.copy();
			flat.p2.x += flatwidth*.7071; // assume 45 degrees initially
			flat.p2.y += flatwidth*.7071;
			flat.center = flat.p1.average(flat.p2);
			flat.center.rotate(flat.p1, splitter.angle);
			flat.p2.rotate(flat.p1, splitter.angle);
			drag_handles['flat'].defaultCenter = flat.center.copy();

			
		}
		ctx.strokeStyle="rgb(255,255,255)";
		
		flat.handle = new coord(flat.center.x-1.5, flat.center.y+1.5);
		flat.handle.rotate(flat.center, splitter.angle);
		drag_handles['flat'].place(flat.handle.x, flat.handle.y);
		drag_handles['flat'].draw();
		drag_handles['flat'].flatCenter = flat.center; // save this for later

		p = flat.intersection(splitter.bottom);
		if (flat.isIntersectedPointWithin(p))
			error("flat hits splitter",p);
		
		flat.draw();
		
		//
		// refbeam to flat
		//
		
		// first find focal point if flat wasn't there
		
		colorTestRed();
		var vector = testBeam.belowCube.lines[0].getVector();
		vector.normalize();
		vector.scale(diverger.fl);
		testBeam.focus = diverger.center.copy();
		testBeam.focus.add(vector);
		//testBeam.focus.draw(.3,"rgb(255,255,255)");
		
		testBeam.afterDiverger = testBeam.belowCube.copy();
		testBeam.afterDiverger.advance();
		testBeam.afterDiverger.setP2(testBeam.focus);
		
		p = testBeam.afterDiverger.intersect(flat);
		if (p!=null) error("",p);
		testBeam.afterDiverger.draw();
		
		//testBeam.afterDiverger.lines[0].p2.draw(.3,"rgb(255,255,255)");
		//testBeam.afterDiverger.lines[1].p2.draw(.3,"rgb(255,0,255)");
		
		
		//
		// reflect test beam off flat
		//
		
		//flat.swap();
		testBeam.afterflat = testBeam.afterDiverger.reflect(flat);
		testBeam.afterflat.intersect(clip_line);
		testBeam.afterflat.draw();

		p = diverger.intersection(flat);
		if (flat.isIntersectedPointWithin(p) && diverger.isIntersectedPointWithin(p))
			error("diverger hits flat",p);
		
		testBeam.focus = testBeam.afterflat.focusPoint(); // need this later to calculate yellow dot
		
		//
		// start refbeam off splitter
		//
		colorRefBlue();
		refbeam.cubeRight = laser.incube.reflect(splitter.diagonal);
		p = refbeam.cubeRight.intersect(splitter.right);
		if (p!=null) error("",p);
		refbeam.cubeRight.draw();
		

		
		//
		// refract refbeam out of splitter
		//
		
		refbeam.rightOfCube = refbeam.cubeRight.refract(splitter.right, IOR, 1);
		refbeam.rightOfCube.intersect(clip_line);
		refbeam.rightOfCube.draw();
		
		//
		// returning ref beam
		//
		
		//
		// returning ref beam below diverger
		//
		
		refbeam.belowDiverger = testBeam.belowCube.copy(); // start with test beam above diverger then extend down to flat
		refbeam.belowDiverger.shiftx(-shear);
		p = refbeam.belowDiverger.intersect(flat);
		if (p != null)error("",p);
		
		refbeam.belowDiverger.swap();
		refbeam.belowDiverger.intersect(diverger);
		refbeam.belowDiverger.draw();
		
		//
		// reflect right off FLAT
		//
		
		refbeam.belowDiverger.swap(); // temporarily have this pointing downwards
		refbeam.rightOfFlat = refbeam.belowDiverger.reflect(flat);
		refbeam.rightOfFlat.intersect(clip_line);
		refbeam.rightOfFlat.swap();
		refbeam.rightOfFlat.draw();
		refbeam.belowDiverger.swap(); // restore
		
		//
		// ref beam above diverger
		//
		
		//
		// calculate focus point (not affected by shear)
		//
		
		vector.rotate180();
		vector.normalize();
		vector.scale(diverger.fl);
		var testBeamRightOfSplitterAngle = vector.copy(); // save for later
		refbeam.focus_before_refraction = diverger.center.copy();
		refbeam.focus_before_refraction.add(vector);
		
		//
		// refbeam above diverger
		//
		
		refbeam.afterDiverger = refbeam.belowDiverger.copy();
		refbeam.afterDiverger.advance();
		refbeam.afterDiverger.setP2(refbeam.focus_before_refraction);
		p = refbeam.afterDiverger.intersect(splitter.bottom);
		if (p != null)
			error("returning reference beam missing splitter",p);
		refbeam.afterDiverger.draw();
		
		//
		// refract refbeam into splitter bottom
		//

		splitter.bottom.swap();
		refbeam.lowerCube = refbeam.afterDiverger.refract(splitter.bottom, 1, IOR);
		p = refbeam.lowerCube.intersect(splitter.diagonal);
		if (p != null) error("",p);
		refbeam.lowerCube.draw();
		
		//
		// reflect refbeam off splitter diagonal
		//
		
		refbeam.leftCube = refbeam.lowerCube.reflect(splitter.diagonal);
		p = refbeam.leftCube.intersect(splitter.left);
		if (p != null) error("",p);
		refbeam.leftCube.draw();
		
		//
		// refract refbeam to the left out of cube
		//
		
		var clip_line_left = new line(new coord(2,0), new coord(2,1));
		refbeam.leftOfCube = refbeam.leftCube.refract(splitter.left, IOR, 1);
		refbeam.leftOfCube.intersect(clip_line_left);
		refbeam.leftOfCube.draw();

		//
		// testbeam returning from mirror
		//
		
		colorTestRed();
		
		//
		// determine refbeam focus point
		//
		
		// we start with focus point of "ref beam after (above) diverger" - where those lines intersect if there was no cube
		
		// reflect that focus point across splitter diagonal

		testBeam.focus_before_refraction = reflectPointAcrossLine(splitter.diagonal, refbeam.afterDiverger.focusPoint());
		
		// move by beam shear
		testBeam.focus_before_refraction.y -= shear;
		// also move by defocus
		testBeam.focus_before_refraction.x +=defocus_mm; // positive defocus means outside focus;

		//testBeam.focus_before_refraction.draw(.2,"rgb(255,255,255)");
		testBeam.rightOfCube = new beam(
			new line(testBeam.focus_before_refraction.copy(), testBeam.focus_before_refraction.copy()),
			new line(testBeam.focus_before_refraction.copy(), testBeam.focus_before_refraction.copy()));
		
		// adjust beam start to represent f/# of mirror being tested
		testBeam.fratio = fnum*2;
		testBeam.rightOfCube.lines[0].p1.x += 4*testBeam.fratio;
		testBeam.rightOfCube.lines[1].p1.x += 4*testBeam.fratio;
		testBeam.rightOfCube.lines[0].p1.y += 2;
		testBeam.rightOfCube.lines[1].p1.y -= 2;
		
		// rotate by same amount as laser
		for(i=0;i<2;i++)
			testBeam.rightOfCube.lines[i].p1.rotate(testBeam.rightOfCube.lines[i].p2, -laser_rotation + splitter.angle*2);

		// now intersect these beams with right of cube and clip_line
		
		testBeam.rightOfCube.swap();
		testBeam.rightOfCube.intersect(clip_line);
		testBeam.rightOfCube.swap();
		p = testBeam.rightOfCube.intersect(splitter.right);
		if (p!=null) error("",p);
		testBeam.rightOfCube.draw();
		
		//
		// refract test beam into cube
		//
		
		splitter.right.swap();
		testBeam.cubeRight = testBeam.rightOfCube.refract(splitter.right, 1, IOR);
		p = testBeam.cubeRight.intersect(splitter.left);
		if (p!=null) error("",p);
		testBeam.cubeRight.draw();
		
		//
		// refract test beam out of cube
		//
		
		testBeam.LeftOfCube = testBeam.cubeRight.refract(splitter.left, IOR, 1);
		testBeam.LeftOfCube.intersect(clip_line_left);
		testBeam.LeftOfCube.draw();

		mirrorFocus2 = testBeam.rightOfCube.focusPoint();
		mirrorFocus2.draw(0.1, "rgb(0,255,0)"); // green dot
		

	}

    
    
    
    // find average of the two mirror focus points to get CoC of mirror
    var mirrorCoC = testBeam.focus.average(mirrorFocus2);
    mirrorCoC.draw(0.1, "rgb(255,255,0)");
    
    // cyan dot aka F3
    var f3 = testBeam.LeftOfCube.focusPoint();
    if (bF3)
    {
        f3.draw(0.2, "rgb(0,0,255)");
        //var dist = f3.lengthTo(splitter.tl.average(splitter.bl)); // cube may be rotated - distance from center of left edge of cube to F3
        var dist = splitter.left.distToPoint(f3)
        document.getElementById('idSpnF3').innerHTML = "<br>Left edge of cube to blue dot: "+dist.toFixed(1)+"mm";
    }
    else
        document.getElementById('idSpnF3').innerHTML = ""

    
    

    if (bLarge)
        ctx.font = '40px sans';
    else
        ctx.font = '20px sans';
	var x,y;
    ctx.fillStyle="rgb(255,255,255)";
	if (bDivergerBelowCube)
	{
		x = refbeam.rightOfFlat.lines[0].p1.x;
		y = (refbeam.rightOfFlat.lines[0].p1.y + refbeam.rightOfCube.lines[1].p2.y)/2;
	}
	else if (bDivergerAtCube)
	{
		x = refbeam.rightOfFlat.lines[0].p2.x;
		y = (refbeam.rightOfFlat.lines[0].p2.y + refbeam.afterDiverger.lines[1].p1.y)/2;
	}
	else
	{
		x = refbeam.toDiverger.lines[0].p1.x;
		y = (refbeam.toDiverger.lines[0].p2.y + refbeam.rightOfCube.lines[1].p1.y)/2;
	}
	
	
    ctx.fillText('To F/'+fnum+' mirror->', 
                          (x-5) * units_per_mm,
                          (y+.5) * units_per_mm );    
    
}

create_handles();
fringes(100); // calls update()

</script>


