<!DOCTYPE html>
<!--
todo:
Shouldn't recalculate igram when nothing changed
test on safari, firefox



Helps you pick out a camera and lens for interferometry

version 1.3
1.0 initial release
1.1 Added search control for narrowing down cameras
1.2 minor changes: "start by entering mirror details", added sony cameras, automatically detects if you just need 4k pixels and no other issues,
                   added iphone 11, recommended camera chooser has major updates including only Nikon cropped cameras
1.3 fixed bug in recommend() where it wasn't setting the sensor size and if you had recently chosen an iphone it messed up
-->


<head>
  <title>
  Camera and Lens chooser tool for Bath Interferometry
  </title>
  <style>
  body {
    font-family: sans-serif;
  }
  button {
    border-radius : 0.3em;
  }
  @media (max-width: 1000px){
      body, td, input, br, button, select { font-size: 3vw; 
      text-size-adjust: 100%; /* Prevent automatic scaling */
      -webkit-text-size-adjust: 100%; /* For WebKit browsers */
    }
    input[type="radio"] {width: 2.3vw; height: 2.3vw;}
   .info {width: 2.3vw;}
  }
  @media (min-width:1000px){
      body, td, input, br, button, select { font-size: 30px; 
      text-size-adjust: 100%; /* Prevent automatic scaling */
      -webkit-text-size-adjust: 100%; /* For WebKit browsers */
    }
    input[type="radio"] {width: 20px; height: 20px;}
   .info {width: 23px;}
  }
  .overlay {
       opacity: 0.5; 
       position:fixed;
       top:0;
       left:0;
       height:100%;
       width:100%;
       background-color:black;
       z-index:5;
  }  
  button {margin: 0.15em;}
  .graybox {
    display: inline-block;
    border:1px solid black;
    border-radius:10px;
    padding:5px;
    background-color:#E0E0E0;
  }
  h3 {
    margin-top:15px;
    margin-bottom:15px;
    }
  .cls_null {
    color:gray;
    font-size: smaller;
  }
}

  </style>
</head>

<body>
<h2>Camera and Lens chooser tool for Bath Interferometry</h2>


<table border="0" style="border:1px black solid;padding:5;border-radius:10px;background-color:#E0E0E0;">

<tr>
<td colspan=3>
  <center><h3 id='idStartBy'><font color=blue>Start by entering mirror details</font></h3></center>
  <center><h3>Mirror</h3></center>
</td>
</tr>
<tr>
<td colspan=3>
  Mirror Units: 
  <input type="radio" name="units" id="idmm" value="mm"     onclick="unitclick(this)" checked ><label for="idmm">mm</label>
  <input type="radio" name="units" id="idin" value="inches" onclick="unitclick(this)"><label for="idin">inches</label>
</td>
</tr>
<tr>
 <td rowspan=2 valign=top>
    Mirror diameter
    <input type="text" size=3 value=300 onKeyUp=updateDiam() id="idDiamtxt">
 </td>
 <td>
  <input type="radio" name="radf" id="idradfnum" value="fnum" checked onclick="radfclick(this)"><label for="idradfnum" id="idLabelFnum" >f/#</label>
 </td>
 <td>
  <input type="text"  id="idfnumtxt" value="4" size=3  onKeyUp="fnumchange()" onfocus="fnumfocus()">
 </td>
</tr>
<tr>
 <td>
  <input type="radio" name="radf" id="idradfl" value="fl" onclick="radfclick(this)"><label for="idradfl" id="idLabelFL">focal length</label>
 </td>
 <td>
  <input type="text"  id="idfltxt" value="0" size=3  onKeyUp="flchange()" onfocus="flfocus()">
 </td>
</tr>
<tr>
 <td colspan=3>
   Conic constant <input type="text" size=2 value=-1 id='idCC' onKeyUp="update()">&nbsp;<span id='idNull' class='cls_null'></span><br>
   (-1 for parabolic mirror, 0 for spherical)
 </td>
</tr>
</table>
<br>



<div class='graybox'>
<center><h3>Camera</h3></center>
<div id='idBtnDiv'><button id='idBtnChooseCamera' type='button'>Please click here to choose a camera!</button><span id='idCamDescription'></span></div><p>


<!-- popup window camera type -->
<div id='idPopup1' style="display: inline-block;border:1px solid black;border-radius:10px;padding:5;background-color:#E0E0E0;position:absolute; display:none; margin:10px; padding: 20px;z-index:10;">
<button id='idBtnRec'>I don't have a camera, please recommend one...</button><br>
<button id='idBtnNik'>Nikon...</button><br>
<button id='idBtnCan'>Canon...</button><br>
<button id='idBtnSony'>Sony</button><br>
<button id='idBtnCel'>Cell Phone</button><br>
<button id='idBtnRas'>Raspberry Pi HQ Cam</button><br>
<button id='idBtnWeb'>Web Cam</button><br>
<button id='idBtnOth'>Other</button>
<a href="javascript:void(0);" id='idClose1' style="float:right">Close</a>
</div>

<!-- popup window camera list -->
<div id='idPopup2' style="display: inline-block;border:1px solid black;border-radius:10px;padding:5;background-color:#E0E0E0;position:absolute; display:none; margin:10px; padding: 20px;z-index:10;">
</div>


<!-- popup msgbox -->
<div id='idMsgBox' style="display: inline-block;border:1px solid black;border-radius:10px;padding:5;background-color:#E0E0E0;position:absolute; display:none; margin:10px; padding: 20px;z-index:20;">
<span id='idSpanMsgBox'></span>
<a href="javascript:void(0);" id='idCloseMB' style="float:right">Close</a>
</div>

<!-- popup gray screen -->
<div id='idDarken' class="overlay" style='display:none'></div>

Camera sensor vertical size: <input type="text"  id="idsensor" value="16" size=3 onKeyUp="update()"> mm
<br>

<input type='radio' name='vertSensor' id='idradMegaPix' value='mp' onclick="radMPclick(this)" checked>
<label for="idradMegaPix" id='idLabelMP'>
  Camera megapixels: 
</label>
<input type="text"  id="idtxtMP" value="14.2" size=3 onKeyUp='MPchange()' onfocus='MPFocus()'> 
<label for="idradMegaPix" id="idLabelMP2">
(assume 3:2 sensor ratio)
</label>

<br>
<input type='radio' name='vertSensor' id='idradVertPix' value='vp' onclick="radMPclick(this)">
<label for="idradVertPix" id='idLabelVertPix'>
  Camera sensor vertical pixels: 
</label>
<input type="text"  id="idtxtVertPixels" value="2000" size=4 onKeyUp='vertPixChange()' onfocus='vertPixFocus()'>
<button id='idBtnSearch' title='show all cameras with this resolution or higher'>Search</button>&nbsp;<img src="i.png" class="info" id='idSearch_info'>
</div>

<p>

<div class='graybox'>
<center><h3>Camera Lens</h3></center>
<center><button id='idBtnChooseLens' type='button'>Please click here to choose a lens!</button><span id='idLensDescription'></span></center><p style="margin-bottom:5px;">
Camera lens focal length: <input type="text"  id="idLensFL" value="50" size=3 onKeyUp="update()"> mm &nbsp;&nbsp; 
Lens f/#: <input type="text"  id="idLensFnum" value="1.8" size=3 onKeyUp="update()">
</div>


<br>
<div style="">
Calculated results. Problems detected will have red text.<br>
Camera FOV: <span id='idCamFOV'></span><br>
Mirror FOV: <span id='idMirrorFOV'></span><br>
Diameter of igram in pixels: <span id='idPixelDiam'></span><br>
Pixels per fringe (smallest fringe): 
<span id='idppf'></span>&nbsp;<img src="i.png" class="info" title="abc" id='idppf_info'><br>
<span id='idsac0'>
Estimated portion of igram available after lens cropping (blue circle in diagram below):
<span id='idsac'></span>&nbsp;<img src="i.png" class="info" title="abc" id='idsac_info'><br></span>
<span id='idsac1'></span>
<span id='idNote'></span>
</div>
<br>
<canvas id='idCanvas' width="500" height="602" '></canvas> <!-- 300 for top diagram, 300 for bottom, 2 for gap between -->


<script src="jquery-3.7.1.min.js"></script> 
<script>
// brand 1=nikon 2-canon
var selected_cam=null;
var selected_lens=null;

function brand_to_str(brand)
{
  switch(brand)
  {
    case 1:return "Nikon";
    case 2:return "Canon";
    case 3:return "Olympus";
  }
}
var camera_data=
[
{brand:1,name:"D1",sensor_mm:15.6,sensor_pixels:1312, prob:"no live view"},
{brand:1,name:"D1H",sensor_mm:15.6,prob:"no live view"},
{brand:1,name:"D1X",sensor_mm:15.6,prob:"no live view"},
{brand:1,name:"D2H",sensor_mm:15.6,prob:"no live view"},
{brand:1,name:"D2Hs",sensor_mm:15.6,prob:"no live view"},
{brand:1,name:"D2Xs",sensor_mm:15.6,prob:"no live view"},
{brand:1,name:"D3",sensor_mm:23.9,sensor_pixels:2832},
{brand:1,name:"D3X",sensor_mm:23.9,sensor_pixels:4032},
{brand:1,name:"D3S",sensor_mm:23.9,sensor_pixels:2832},
{brand:1,name:"D4",sensor_mm:23.9,sensor_pixels:3280},
{brand:1,name:"D4S",sensor_mm:23.9,sensor_pixels:3280},
{brand:1,name:"D5",sensor_mm:23.9,sensor_pixels:3712},
{brand:1,name:"D6",sensor_mm:23.9,sensor_pixels:3712},
{brand:1,name:"D40",prob:"no live view"},
{brand:1,name:"D40x",prob:"no live view"},
{brand:1,name:"D60",prob:"no live view"},
{brand:1,name:"D3000",prob:"no live view"},
{brand:1,name:"D3100",sensor_mm:15.4,sensor_pixels:3072},
{brand:1,name:"D3200",sensor_mm:15.4,sensor_pixels:4000},
{brand:1,name:"D3300",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D3400",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D3500",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D5000",sensor_mm:15.8,sensor_pixels:2848},
{brand:1,name:"D5100",sensor_mm:15.8,sensor_pixels:3264},
{brand:1,name:"D5200",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D5300",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D5500",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D5600",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D50",sensor_mm:15.8,sensor_pixels:2000,prob:"no live view"},
{brand:1,name:"D70",prob:"no live view"},
{brand:1,name:"D70s",prob:"no live view"},
{brand:1,name:"D80",prob:"no live view"},
{brand:1,name:"D90",sensor_mm:15.8,sensor_pixels:2848},
{brand:1,name:"D7000",sensor_mm:15.6,sensor_pixels:3264},
{brand:1,name:"D7100",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D7200",sensor_mm:15.6,sensor_pixels:4000},
{brand:1,name:"D7500",sensor_mm:15.7,sensor_pixels:3712},
{brand:1,name:"D100",prob:"no live view"},
{brand:1,name:"D200",prob:"no live view"},
{brand:1,name:"D300",sensor_mm:15.8,sensor_pixels:2848},
{brand:1,name:"D300s",sensor_mm:15.8,sensor_pixels:2848},
{brand:1,name:"D500",sensor_mm:15.7,sensor_pixels:3712},
{brand:1,name:"D600",sensor_mm:23.9,sensor_pixels:4016},
{brand:1,name:"D610",sensor_mm:23.9,sensor_pixels:4016},
{brand:1,name:"D750",sensor_mm:23.9,sensor_pixels:4016},
{brand:1,name:"D780",sensor_mm:23.9,sensor_pixels:4024},
{brand:1,name:"D700",sensor_mm:23.9,sensor_pixels:2832},
{brand:1,name:"D800",sensor_mm:24,sensor_pixels:4912},
{brand:1,name:"D800E",sensor_mm:24,sensor_pixels:4912},
{brand:1,name:"Df",sensor_mm:23.9,sensor_pixels:3280},
{brand:1,name:"D810",sensor_mm:24,sensor_pixels:4912},
{brand:1,name:"D810A",sensor_mm:24,sensor_pixels:4912},
{brand:1,name:"D850",sensor_mm:23.9,sensor_pixels:5504},
{brand:1,name:"Z30",sensor_mm:15.7,sensor_pixels:3712},
{brand:1,name:"Z50",sensor_mm:15.7,sensor_pixels:3712},
{brand:1,name:"Z50ii",sensor_mm:15.7,sensor_pixels:3712},
{brand:1,name:"Zfc",sensor_mm:15.7,sensor_pixels:3712},
{brand:1,name:"Z5",sensor_mm:23.9,sensor_pixels:4016},
{brand:1,name:"Zf",sensor_mm:23.9,sensor_pixels:4032},
{brand:1,name:"Z6",sensor_mm:23.9,sensor_pixels:4032},
{brand:1,name:"Z6ii",sensor_mm:23.9,sensor_pixels:4032},
{brand:1,name:"Z7",sensor_mm:23.9,sensor_pixels:5504},
{brand:1,name:"Z7ii",sensor_mm:23.9,sensor_pixels:5504},
{brand:1,name:"Z8",sensor_mm:23.9,sensor_pixels:5504},
{brand:1,name:"Z9",sensor_mm:23.9,sensor_pixels:5504},


{brand:2,name:"EOS 1DC",sensor_mm:24,mp:17.9},
{brand:2,name:"EOS 1DX",sensor_mm:24,mp:17.9},
{brand:2,name:"EOS 1DX Mark ii",sensor_mm:23.9,mp:20},
{brand:2,name:"EOS 1DX Mark iii",sensor_mm:24,mp:20},

{brand:2,name:"EOS 1DS",prob:"no live view"},
{brand:2,name:"EOS 1DS Mark ii",prob:"no live view"},
{brand:2,name:"EOS 1DS Mark iii",sensor_mm:24,mp:21},
{brand:2,name:"EOS 1DS Mark iv",sensor_mm:18.6,sensor_pixels:3264},

{brand:2,name:"EOS 1D",prob:"no live view"},
{brand:2,name:"EOS 1D Mark ii",prob:"no live view"},
{brand:2,name:"EOS 1D Mark ii N",prob:"no live view"},
{brand:2,name:"EOS 1D Mark III",sensor_mm:18.7,sensor_pixels:2594},

{brand:2,name:"EOS 5D",prob:"no live view"},
{brand:2,name:"EOS 5D Mark ii",sensor_mm:24,mp:21},
{brand:2,name:"EOS 5D Mark iii",sensor_mm:24,mp:22.1},
{brand:2,name:"EOS 5D Mark iv",sensor_mm:24,mp:30.1},
{brand:2,name:"EOS 5DS",sensor_mm:24,mp:50.3},
{brand:2,name:"EOS 5DS R",sensor_mm:24,mp:50.3},

{brand:2,name:"EOS 6D",sensor_mm:24,mp:20},
{brand:2,name:"EOS 6D Mark ii",sensor_mm:24,mp:26},

{brand:2,name:"EOS 7D",sensor_mm:14.9,mp:17.9},
{brand:2,name:"EOS 7D Mark ii",sensor_mm:15,mp:20.0},

{brand:2,name:"EOS 70D",sensor_mm:15,mp:20},

{brand:2,name:"EOS 77D",sensor_mm:14.9,mp:24},

{brand:2,name:"EOS 80D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS 90D",sensor_mm:14.8,mp:32.3},

{brand:2,name:"EOS 60Da",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS 60D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS 50D",sensor_mm:14.9,sensor_pixels:3168},
{brand:2,name:"EOS 40D",sensor_mm:14.8,sensor_pixels:2592},
{brand:2,name:"EOS 30D",prob:"no live view"},
{brand:2,name:"EOS 20D",prob:"no live view"},
{brand:2,name:"EOS 20Da",sensor_mm:15,sensor_pixels:2344},
{brand:2,name:"EOS 10D",prob:"no live view"},
{brand:2,name:"EOS SL1/100D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS SL2/200D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS SL3/250D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS DIGITAL REBEL/300D",prob:"no live view"},


{brand:2,name:"EOS XT/350D",prob:"no live view"},
{brand:2,name:"EOS XTi/400D",prob:"no live view"},

{brand:2,name:"EOS XSi/450D",sensor_mm:14.8,mp:12.2},
{brand:2,name:"EOS T1I/500D",sensor_mm:14.9,sensor_pixels:3168},
{brand:2,name:"EOS T2i/550D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS T3i/600D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS T4i/650D",sensor_mm:14.9,sensor_pixels:3456},

{brand:2,name:"EOS T5i/700D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS T6i/750D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS T6S/760D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS T7i/800D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS T8i/850D",sensor_mm:14.9,mp:24},

{brand:2,name:"EOS T3/1100D",sensor_mm:14.8,mp:12.2},
{brand:2,name:"EOS T5/1200D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS T6/1300D",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS T7/2000D",sensor_mm:14.9,mp:24},
{brand:2,name:"EOS T100/4000D",sensor_mm:14.9,sensor_pixels:3456},

{brand:2,name:"EOS M",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS M2",sensor_mm:14.9,sensor_pixels:3476},
{brand:2,name:"EOS M3",sensor_mm:14.9,mp:24.2},
{brand:2,name:"EOS M5",sensor_mm:14.9,mp:24.2},
{brand:2,name:"EOS M6",sensor_mm:14.9,mp:24.2},
{brand:2,name:"EOS M6 Mark ii",sensor_mm:24,mp:31.7},
{brand:2,name:"EOS M10",sensor_mm:14.9,sensor_pixels:3456},
{brand:2,name:"EOS M50",sensor_mm:14.9,mp:24.1},
{brand:2,name:"EOS M50 Mark ii",sensor_mm:14.9,mp:24.1},
{brand:2,name:"EOS M100",sensor_mm:14.9,sensor_pixels:4000},
{brand:2,name:"EOS M200",sensor_mm:14.9,sensor_pixels:4000},

{brand:2,name:"EOS R",sensor_mm:24,sensor_pixels:4480},
{brand:2,name:"EOS Ra",sensor_mm:24,sensor_pixels:2160},
{brand:2,name:"EOS RP",sensor_mm:24,mp:26.2},
{brand:2,name:"EOS R1",sensor_mm:24,mp:24.2},
{brand:2,name:"EOS R3",sensor_mm:24,sensor_pixels:4000},
{brand:2,name:"EOS R5",sensor_mm:24,sensor_pixels:5464},
{brand:2,name:"EOS R5 Mark ii",sensor_mm:24,mp:45},
{brand:2,name:"EOS R6",sensor_mm:24,sensor_pixels:3648},
{brand:2,name:"EOS R6 Mark ii",sensor_mm:24,mp:24.2},
{brand:2,name:"EOS R7",sensor_mm:14.8,mp:32.5},
{brand:2,name:"EOS R8",sensor_mm:24,mp:24.2},
{brand:2,name:"EOS R10",sensor_mm:14.9,sensor_pixels:4000},
{brand:2,name:"EOS R50",sensor_mm:14.9,mp:24.2},
{brand:2,name:"EOS R100",sensor_mm:24,mp:24.1},
];

function isMirrorless(cam)
{
  if (cam.brand==1 && cam.name.substr(0,1)=="Z") return true;
  if (cam.brand==2 && (cam.name.substr(0,5)=="EOS M" || cam.name.substr(0,5)=="EOS R")) return true;
  return false;
}
function findCam(name)
{
  // returns index into array
  for(i=0;i<camera_data.length; i++)
  {
    if (camera_data[i].name == name)
      return i;
  }
  return -1;
}
camera_data.sort(function(a,b)
  {
    var am=isMirrorless(a);
    var bm=isMirrorless(b);
    if (am==bm)
      return a.name.localeCompare(b.name,'en',{numeric:true})
    if (am) return 1;
    return -1;
  });
console.log(camera_data.length);
/*
for(i=0; i<camera_data.length; i++)
{
  cam = camera_data[i];
  if (cam.prob)continue;
  var pix;
  if (cam.sensor_pixels)
    pix = cam.sensor_pixels;
  else
    pix = Math.sqrt(cam.mp*1000000/1.5);
  if (pix>5000)
    console.log(cam.name+" sensor "+pix);
}*/

function makeCameraRadios(brand, minpixels, sens_type)
{
  // type 0=all 1=full frame 2=small sensor
  if (!sens_type)sens_type=0;
  save_brand = brand;
  save_minpixels = minpixels;
  str="";
  if (minpixels)
    str+="<select id='idselsens'><option value=0>all</option><option value=1>full frame (sometimes better when mirror&lt;F/2)</option><option value=2>small sensor (usually better)</option></select><br>";
  column=0;
  prev_cam="";
  for(i=0; i<camera_data.length; i++)
  {
    cam = camera_data[i];
    if (brand != "*" && cam.brand != brand) continue;
    if (minpixels && get_vert_pixels(i) < minpixels) continue;
    if (minpixels && cam.prob) continue;
    if (sens_type==1 && cam.sensor_mm < 20) continue;
    if (sens_type==2 && cam.sensor_mm > 20) continue;
    column++;
    
    if (cam.brand != prev_cam.brand)
    {
      
      str+="<p>"+brand_to_str(cam.brand)+"<br>";
      column=1;
    }else if (isMirrorless(cam) && isMirrorless(prev_cam) == false)
    {
      str+="<p>mirrorless<br>";
      column=1;
    }
    str+= "<button onclick='chose_cam("+i+")'";
    if (cam.prob) 
      str+=" style='color:#900'";
    else if (["D3100","D3200","D3300","D3400"].includes(cam.name) ||
       cam.name.indexOf("1100D")>=0 ||
       cam.name.indexOf("1200D")>=0 ||
       cam.name.indexOf("1300D")>=0 ||
       cam.name.indexOf("2000D")>=0
    )
      str+=" style='color:#090'";
    str+=">"+cam.name+"</button>";
    if (column % 4 == 0) 
      str+="<br>";
    else
      str+=" ";
    prev_cam=cam;
  }
  str+="<a href='javascript:void(0);' id='idClose2' style='float:right'>Close</a>";
  $('#idPopup2').html(str);
  $('#idselsens').val(sens_type);
  $('#idselsens').change(sensor_select_changed);
  $('#idClose2').click(close_dialog2);
}
var save_brand;
var save_minpixels;
function sensor_select_changed()
{
  makeCameraRadios(save_brand, save_minpixels, $('#idselsens').val());
}


var chosen_cam=false;
function chose_cam(i,bDontCloseMessageBox)
{
  cam = camera_data[i];
  chosen_cam=cam;
  if (cam.prob)
  {
    messagebox("This camera (and all the red ones) don't have live view.  You really can't use this camera. Do you have another? I recommend one of the green ones which are around USD $200 used.",null);
    return;
  }
  selected_cam = cam;
  $('#idsensor').val(cam.sensor_mm);
  if (cam.sensor_pixels)
  {
    $('#idtxtMP').val((cam.sensor_pixels*cam.sensor_pixels*1.5/1000000).toFixed(1));
    $('#idtxtVertPixels').val(cam.sensor_pixels);
    vertPixFocus();
  }
  else
  {
    $('#idtxtMP').val(cam.mp);
    $('#idtxtVertPixels').val(Math.round(Math.sqrt(cam.mp*1000000/1.5)));
    MPFocus();
  }
  $('#idLensFL').val("50");
  $('#idLensFnum').val("2");
  var brand;
  switch (cam.brand)
  {
    case 1:
      brand ="Nikon";
      break;
    case 2:
      brand ="Canon";
      break;
  }
  
  $('#idCamDescription').text(brand+" "+cam.name);
  $('#idCamDescription').css("color","blue");
  close_dialog2();
  update();
  $('#idBtnChooseCamera').css("color","black");
  $('#idBtnChooseCamera').text("click to change camera");
  // now we have lots of data - let's see what minimum pixels are for a 50mm lens is, see what range of lenses will work well
  
  // max focal length such that any higher focal length will crop the image (no margin included) 
  max_focal_length = 50* mirrorFOV / camFOV;
  // minimum focal length such that we run out of pixels (no margin included)
  min_focal_length = 50*4/ppf;
  
  //alert("min fl: "+min_focal_length.toFixed(1)+"  max fl: "+max_focal_length.toFixed(1));
  if (bDontCloseMessageBox == null || bDontCloseMessageBox == false)
    $('#idMsgBox').fadeOut(200);
  
  
  /*
var sensorPixels;  // vertical
var lensFL;
var sensorMM;
var camFOV;        // ratio - 2 means F/2
var mirrorFOV;     // ratio (2x the mirror F/# so 8.2 for an F/4.1 mirror)
var camFOVdeg;     // in degrees
var mirrorFOVdeg;  // in degrees
var mirrorFOVmm;
var cc;            // conic constant
var mirror_diam;   // in mm
var z8;            // null value in wyant waves of S.A.
var ppf;           // pixels per fringe worst case  
  */
  
  
}


function info_text(id, txt)
{
  // set both hover and click text for this help button
  $('#'+id).attr('title', txt);
  $('#'+id).click(function(){alert(txt);})
}

info_text('idppf_info', "You need at least 4 pixels per fringe for color cameras due to the bayer filter. 2ppf on bw cameras with no bayer filter.");
info_text('idsac_info', "Must be > 100%. This is hard to explain and I hope to post a video but your lens aperture might not be big enough to fit the whole igram. The igram is a cone of light exiting the interferometer, if that cone expands too fast and you can't get the camera lens close enough to the expanding point then your camera lens will crop the igram and will be unusable.  The text will only turn red if it is estimated that you won't be able to see the whole igram even with the camera lens touching the splitter cube. Estimates are based on 5 lenses for DSLR cameras and not valid for other much smaller lenses such as cell phone lenses.");
info_text('idSearch_info',"Click 'Search' to show all cameras with this resolution or higher");


/*
setSizes();
$(window).resize(setSizes); // call again if window is resized
*/

//
// create an array called "lookup", used by col() (color), that will do a very fast sine wave transformation - much faster than Math.sin()
//
var steps = 400;
var lookup = new Array(steps+1);
for(var i=0; i<steps; i++)
  lookup[i] = (Math.sin( (i-steps/2)/(steps/2)*3.1415926/2)+1)*127;
lookup[steps]=255; // takes care of almost impossible case where input is 1
// col() converts x which is 0 to 1 into an output from 0 to 255 on a sine curve 


let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
//console.log(vw);

var radioPosition="mm"; // versus "inches"
fnumchange();
radfclick(get('idradfnum'));
MPFocus();
radMPclick(get('idradMegaPix'));
MPchange();
update();


function synth_apeture_cropping(fl, aperture, bZoom)
{
  // returns sensor fov in mm.  Note that if we are cropping too much we need larger aperture lens (not necessarily larger focal length)
  // estimates how much cropping will occur due to the inherent synthetic aperture in a Bath Interferometer
  // fl = focal length of lens
  // bZoom is true for zoom lenses (zoom lenses will have a heavily cropped view compared to fixed fl lenses
  var data=[[0,0,0],[28,10,10.8],[35,19.4,14.1],[50,27.8,38.6],[85,47.2,82],[135,67.5,105]];  // fl, aperture, fov in mm
  // find nearest 2 data points and linearly interpolate between
  var i1,i2;
  for(var i=0; i<data.length; i++)
  {
    if (data[i][0]>fl || i == data.length-1)
    {
      if (i==0)
      {
        // return first 2 points
        i1=0;
        i2=1;
      }
      else if (i == data.length-1)
      {
        // return last 2 points
        i2=i;
        i1=i-1;
      }
      else
      {
        i1=i-1;
        i2=i;
      }
      break;
    }
  }
  var fl1=data[i1][0];
  var fl2=data[i2][0];
  var ap1=data[i1][1];
  var ap2=data[i2][1];
  var fov1=data[i1][2];
  var fov2=data[i2][2];
  
  // based on fl, linear interpolate aperture and vfov constants
  
  var li_aperture =  ap1*(fl2-fl)/(fl2-fl1) +  ap2*(fl-fl1)/(fl2-fl1);
  var li_fov      = fov1*(fl2-fl)/(fl2-fl1) + fov2*(fl-fl1)/(fl2-fl1);
  // yes I could have just found ratio of aperture/fov but this is easier for me to read 
  // and even my data table could have stored the ratio
  
  var fovmm = li_fov*aperture/li_aperture; // bigger aperture gives you (roughly linear) bigger field of view
  if (bZoom) fovmm /=2; // obviously very rough and this is from data from only 2 zoom lenses
  return fovmm;
}


function choose_camera_close()
{
  $('#idPopup1').fadeOut(200);
  $('#idDarken').hide();
}
function choose_camera()
{
  $('#idPopup1').fadeIn(200);
  $('#idDarken').show();
}

function get_vert_pixels(i)
{
  var cam=camera_data[i];
  if (cam.sensor_pixels)
    return cam.sensor_pixels;
  else
    return Math.round(Math.sqrt(cam.mp*1000000/1.5));
}

function choose_lens()
{
  if ($('#idCamDescription').text().substr(0,6) == "Ras Pi")
  {
    messagebox("Sorry, not available for this camera at this time.  You'll have to enter manually below.");
    return;
  }

  $('#idLensFL').val('50');
  $('#idLensFnum').val('2');
  update();
  while (mirrorFOVdeg / camFOVdeg >= 1)
  {
    // ppf calculations not done because igram doesn't fit in FOV so start by shrinking lens
    $('#idLensFL').val($('#idLensFL').val()/2);
    update();
  }
  // max focal length such that any higher focal length will crop the image (no margin included) 
  max_focal_length = lensFL* mirrorFOV / camFOV;
  // minimum focal length such that we run out of pixels (no margin included)
  min_focal_length = lensFL*4/ppf;
  
  str="To achieve 4 pixels per fringe, absolute <b>minimum focal length</b>: "+min_focal_length.toFixed(1)+"<br>";
  str+="To keep igram within vertical field of view <b>maximum focal length</b>: "+max_focal_length.toFixed(0)+"<br>";
  
  // are there any lenses in this range?
  
  if (min_focal_length > max_focal_length)
  {
    pixels_needed = Math.round(sensorPixels*min_focal_length/max_focal_length);
    str+="No such lens exists. You need a camera with at least "+pixels_needed+" vertical pixels.<br>";
    var qty=0;
    for (i=0; i<camera_data.length; i++)
      if (get_vert_pixels(i) > pixels_needed)
        qty++;
      else
       console.log(camera_data[i].name);
    str+=""+qty+" cameras in my database have that many pixels.<br>Please solve this issue before choosing a lens.";
    messagebox(str,null,true);
    return;
  }
  
  if (min_focal_length >= 35 && sensorMM > 12 && sensorMM < 18)
  {
    var min_pixels= min_focal_length/40*sensorMM;
    if (sensorMM>12 && sensorMM < 23 && min_pixels < 3300) 
      str+="It might be cheaper to switch to a camera with more megapixels so that you can use a (much cheaper) 50mm lens.<br>";
  }
  
  if (min_focal_length > 40 && sensorMM > 23)
  {
    var min_pixels= min_focal_length/40*sensorMM;
    if (min_pixels > 4000 && min_pixels < 6000)
      str="I didn't do all the math, but there's a good chance it's cheaper to switch from full frame to a camera with a smaller sensor because it will probably save you a lot of money on the lens if you don't already have the right one.<br>";
  }
  
  var sac = synth_apeture_cropping(lensFL, lensFL/lensFNum, false);
  var sac_percent = sac/mirrorFOVmm*100;  

  var bSolutionFound=false;
  // 50mm work?
  if (min_focal_length < 35 && max_focal_length > 55)
  {
    bSolutionFound=true;
    if (sac_percent > 150)
    {
      str+="50mm F/2 lens will work and it's the cheapest possible lens<br>Avoid using zoom lenses because of sac issue.<img src='i.png' class='info' id='idsac_info2'><br>";
    }
    else if (sac_percent > 110)
      str+="50mm F/2 lens will barely work but I recommend you get a wider aperture such as F/1.8 so the lens doesn't have to be right up against the splitter.<br>";
    else if (sac_percent > 60)
    {
      var fnum_desired = sac_percent/100*2; // *2 because F/2 was used to calculate the sac
      str+="50mm focal length works but you need an aperture of F/"+fnum_desired.toFixed(2)+" (or faster) and at that f/# lens it would need to touch the splitter. <br>";
    }
  }
  else if (max_focal_length <= 55 && max_focal_length > 40 && min_focal_length < 25)
  {
    // 35mm?
    $('#idLensFL').val('35');
    $('#idLensFnum').val('1.8');
    update();
    sac = synth_apeture_cropping(lensFL, lensFL/lensFNum, false);
    sac_percent = sac/mirrorFOVmm*100;     
    if (sac > 150)
    {
      str+="35mm F/1.8 will work and not very expensive.<br>Avoid using zoom lenses because of sac issue.<img src='i.png' class='info' id='idsac_info2'><br>";
      bSolutionFound=true;
    }
    else
    {
      var fnum_desired = sac_percent/100*1.8; // *1.8 because F/1.8 was used to calculate the sac
      str+="35mm works but you need an aperture of F/"+fnum_desired.toFixed(2)+" (or faster) and at that f/# lens it would need to touch the splitter<br>";
    }
  }
  
  if (bSolutionFound == false)
  {
    str+="To <b>decrease lens min</b> fl, increase camera resolution.<br>";
    str+="To <b>decrease lens min and max</b> fl, use a camera with a smaller sensor size<br>"; 
  }


if (min_focal_length*2 > max_focal_length)
  {
    
  }
  
  // deal with sac (synth aperture cropping)
  
  
  messagebox(str,null,true);
  info_text('idsac_info2', "Avoid using zoom lenses: This is hard to explain and I hope to post a video but your lens aperture might not be big enough to fit the whole igram. The igram is a cone of light exiting the interferometer, if that cone expands too fast and you can't get the camera lens close enough to the expanding point then your camera lens will crop the igram and will be unusable. This is particularly bad with zoom lenses.  Although less so for lenses whose minimum zoom is 100mm. It's much more of a problem for zoom lenses that can go wide angle.");
}


$('#idBtnChooseCamera').css("color","blue");
$('#idBtnChooseCamera').css("text-align","center");
//$('#idBtnChooseCamera').css("border-radius","0.3em");
$('#idBtnDiv').css("text-align","center");


function col(x) // (color)
{
  return lookup[Math.floor(x*steps)];
}




function min(a,b) { return a<b ? a: b; }

// the following are all filled in when calling update()
var sensorPixels;  // vertical
var lensFL;
var sensorMM;
var camFOV;        // ratio - 2 means F/2
var mirrorFOV;     // ratio (2x the mirror F/# so 8.2 for an F/4.1 mirror)
var camFOVdeg;     // in degrees
var mirrorFOVdeg;  // in degrees
var mirrorFOVmm;   // size of igram on camera sensor
var cc;            // conic constant
var mirror_diam;   // in mm
var z8;            // null value in wyant waves of S.A.
var ppf;           // pixels per fringe worst case
var lensFNum;      // fnum of camera lens

function update()
{
  // calculate igram size on sensor
  
  sensorPixels = parseFloat(get('idtxtVertPixels').value);
  lensFL = parseFloat(get('idLensFL').value);

  sensorMM = parseFloat(get('idsensor').value);
  camFOV = lensFL/sensorMM;
  camFOVdeg = Math.atan(1/camFOV/2)*2*180/3.14159;
  mirrorFNum = parseFloat(get('idfnumtxt').value);
  mirrorFOV = mirrorFNum*2;
  mirrorFOVdeg = Math.atan(1/mirrorFOV/2)*2*180/3.14159;
  mirrorFOVmm = camFOV/mirrorFOV*sensorMM;
  cc = parseFloat(get('idCC').value);
  mirror_diam = get('idDiamtxt').value;
  if (get('idin').checked)
    mirror_diam *=25.4;
  lensFNum = $('#idLensFnum').val();
    
  $('#idsac1').html('');
  $('#idNote').html('');
  
  var mirrorROC = $('#idfltxt').val()*2;
  if (radioPosition != "mm")
    mirrorROC*=25.4;
  if (mirrorROC < 300)
     $('#idNote').html("<br><font color='#ec0'>Your focal length is very short. Some camera lenses can't focus this short.  Please check for this issue yourself.  The camera lens needs to be able to focus at a distance of "+(mirrorROC/10).toFixed(0)+" cm</font>");
  
  var wl=650;
  z8 = cc*(mirror_diam/(wl/1000000))/(3072 * mirrorFNum * mirrorFNum * mirrorFNum);
  $('#idNull').text("SA Null "+z8.toFixed(1)+" Waves");
  
  
  get('idMirrorFOV').innerHTML=mirrorFOVdeg.toFixed(1)+" deg";
  if (mirrorFOVdeg > camFOVdeg)
  {
      suggested_camera_focal_length = mirrorFOV*sensorMM;
      get('idCamFOV').innerHTML=camFOVdeg.toFixed(1)+" deg (need cam lens f.l. < "+suggested_camera_focal_length.toFixed(0)+"mm)";
      get('idCamFOV').style.color='red';
  }
  else if (mirrorFOVdeg*1.2 > camFOVdeg)
  {
      get('idCamFOV').innerHTML=camFOVdeg.toFixed(1)+" deg (Field of View) (shorter f.l. lens might be better)";
      get('idCamFOV').style.color='#ec0';
  }
  else
  {
      get('idCamFOV').innerHTML=camFOVdeg.toFixed(1)+" deg (Field of View)";
      get('idCamFOV').style.color='black';
  }
  
  igramPixels = sensorPixels * camFOV/mirrorFOV;
  get('idPixelDiam').innerHTML = igramPixels.toFixed(0);
  
  t_can = document.getElementById('idCanvas');
  ctx = t_can.getContext('2d');
  
  canvas_width = t_can.clientWidth;
  canvas_height = (t_can.clientHeight-2)/2;
  
  //
  // draw background top half white
  //
  
  ctx.fillStyle = 'rgb(255,255,255)';
  ctx.fillRect(0, 0, canvas_width, canvas_height);
  
  camera_ratio=3/2; // width/height
  
  width = min(canvas_width, canvas_height*camera_ratio);
  height = width/camera_ratio;
  scale = min(height/sensorMM, height/mirrorFOVmm);
  xoff = canvas_width/2;
  yoff = canvas_height/2;


  // sensor fov
  pixW = sensorMM*camera_ratio*scale;
  pixH = sensorMM*scale;

  //
  // draw sensor rectangle black
  //
  
  ctx.fillStyle="black";
  ctx.fillRect(xoff - pixW/2, yoff-pixH/2, pixW, pixH);

  // 
  // draw red circle representing igram
  //
  ctx.lineWidth=1;
  ctx.strokeStyle="rgb(255,0,0)";
  ctx.beginPath();
  ctx.arc(xoff, yoff, mirrorFOVmm*scale/2, 0, 2*Math.PI); // divide by 2 because it's radius, not diameter
  ctx.stroke();
  
  pixels = Math.round(mirrorFOVmm*scale,0);
  if (mirrorFOVdeg / camFOVdeg < 1)
  {
  /*
z8  def  tilt
-10 12   70
-5  6    35
-1  1.5  7
.5  */

    tilt=-z8*7+4;
    defocus=-z8*1.2+.3;
    astig=0;
    oversample=2000/pixels*Math.abs(z8)/10;
    if (oversample > 10) oversample=10; // otherwise it gets too slow on cpu
    if (oversample < 1) oversample=1;
    
    //
    // Draw actual igram (upper drawing)
    //
    
    ppf = fringes(ctx, pixels, xoff-mirrorFOVmm*scale/2,yoff-mirrorFOVmm*scale/2,
                  z8,tilt,defocus,astig,655, oversample);
    
    ppf = ppf*igramPixels/pixels;
    if (ppf > 4.4) // assumes bayer filter and 10% margin
      get('idppf').innerHTML=ppf.toFixed(1);
    else if (ppf > 4)
      // yellow
      get('idppf').innerHTML="<bold><font color='#ec0'>"+ppf.toFixed(1)+"</font></bold>"
    else
    {
      if (mirrorFOVdeg / camFOVdeg > 0.75)
        get('idppf').innerHTML="<font color='red'>"+ppf.toFixed(1)+"</font> Not enough pixels. Need more pixels in camera."
      else
        get('idppf').innerHTML="<font color='red'>"+ppf.toFixed(1)+"</font> Not enough pixels. Need longer focal length lens or more pixels in camera."
    }
    
  }
  var sac = synth_apeture_cropping(lensFL, lensFL/lensFNum, false);
  var sac_percent = sac/mirrorFOVmm*100;
  if (sac >= sensorMM*1.5)
  {
    // no vigneting due to sac
    $('#idsac0').hide();
  }
  else
  {
    $('#idsac0').show();
    if (sac_percent < 200)
      $('#idsac1').html("<br><font color='#eco'>Your mirror f/# is very low so you need to worry about synthetic aperture cropping (sac). Please contact me about this at thegr5store@gmail.com. I have tested a few wide angle lenses (28mm, 35mm) but the newer longer body lenses probably won't work for you and I can tell you what works and what doesn't and how you can test a lens for sac issues. You might also need a custom made lens.</font>");
    $('#idsac').text(""+sac_percent.toFixed(0)+"%");
    if (sac_percent < 100)
      $('#idsac').css("color", "red");
    else if (sac_percent < 120)
      $('#idsac').css("color", "#ec0");
    else
      $('#idsac').css("color", "black");
    
    // draw blue aperture circle
    if (sac_percent >= 100)
      ctx.strokeStyle="rgb(90,90,255)";
    else
      ctx.strokeStyle="rgb(0,0,255)";
    ctx.beginPath();
    ctx.arc(xoff, yoff, sac*scale/2, 0, 2*Math.PI); // divide by 2 because it's radius, not diameter
    ctx.stroke();    
  }
  
  //
  // Add text to upper view
  //
  
  ctx.font = '20px sans';
  ctx.fillStyle="rgb(130,130,130)";
  ctx.fillText('Camera FOV', xoff-pixW/2+5, yoff-pixH/2+25); // 25 is font height plus margin, 5 is left margin

  // now zoom window in lower half
  
  //
  // draw white strip between upper and lower view
  //
  
  ctx.fillStyle = 'rgb(255,255,255)';
  ctx.fillRect(0, canvas_height, canvas_width, 2);
  
  zoom = 2*canvas_height/pixels;
  if (zoom<5) zoom=5;// 5x minimum
  
  //
  // fill lower box black
  // 
  
  ctx.fillStyle="rgb(0,0,0)";
  ctx.fillRect(0, canvas_height+2, canvas_width, canvas_height);
  
  //
  // draw zoomed in igram
  //
  
  fringes(ctx, pixels*zoom, 20, 302,
                  z8,tilt,defocus,astig,655, 1,500,300);
  //
  // text in lower view
  //
  
  ctx.font = '20px sans';
  ctx.fillStyle="rgb(130,130,130)";
  ctx.fillText('Zoom View', 5, canvas_height+25); // 25 is font height plus margin, 5 is left margin

}

function nmToRGB(wavelength)
{

  if((wavelength < 440)){
    red = 0;
    green = 0.0;
    blue = 1.0;
  }else if((wavelength >= 440) && (wavelength<490)){
    red = 0.0;
    green = (wavelength - 440) / (490 - 440);
    blue = 1.0;
  }else if((wavelength >= 490) && (wavelength<510)){
    red = 0.0;
    green = 1.0;
    blue = -(wavelength - 510) / (510 - 490);
  }else if((wavelength >= 510) && (wavelength<580)){
    red = (wavelength - 510) / (580 - 510);
    green = 1.0;
    blue = 0.0;
  }else if((wavelength >= 580) && (wavelength<645)){
    red = 1.0;
    green = -(wavelength - 645) / (645 - 580);
    blue = 0.0;
  }else if((wavelength >= 645) && (wavelength<781)){
    red = 1.0;
    green = 0.0;
    blue = 0.0;
  }else{
    red = 1.0;
    green = 0.0;
    blue = 0.0;
  };
  return [red,green,blue];
  //return "rgb("+red+","+green+","+blue+")";
  
}

function bytediv(a,b)
{
  // divide a by b where both are integers and result needs to be integer from 0 to 255
  return min(Math.round(a/b,0), 255);
}


function fringes(ctx,pixels,offsetX,offsetY,z8,tilt,defocus,astig,wavelength, oversample,img_width,img_height)
{
    // if oversample is for example 2 then we calculate average of 4X (2 squared) pixels per actual pixel for anti-aliasing
    oversample = Math.round(oversample,0); // must be integer
    var startTime = new Date();

    var id;
    if (img_width>0)
      id = ctx.createImageData(img_width,img_height);
    else
      id = ctx.createImageData(pixels,pixels);
    var pix = id.data;

    //var t = document.getElementById('idlogging');

    var rgb = nmToRGB(wavelength);
    var red = rgb[0];
    var green = rgb[1];
    var blue = rgb[2];
    var rsum,gsum,bsum; // adds up RGB color before averaging




  
    
    // fill background color
    /*ctx.fillStyle = 'rgb('+red*80+','+green*80+','+blue*80+')';
    ctx.fillRect(0, 0, canvas_size-1, canvas_size-1);
    ctx.fillStyle = 'rgb(200,200,200)';*/
    
    // create sinwave shortcut

    // loop through every pixel
    var c_z8 = z8;//Math.sqrt(5);
    var c_tilt = tilt;
    var c_def = defocus;//Math.sqrt(3);
    var c_astig = astig;//astig*Math.sqrt(6);
    var pixels2 = pixels/2; // radius of igram in pixels
    /*
    if (img_width>0)
      pix[4*img_width*img_height-1]=255; // thought this might save time as it might create the array all at once?
    else
      pix[4*pixels*pixels-1]=255; // thought this might save time as it might create the array all at once?
*/

    /*pix[1]=0;
    pix[2]=0;
    pix[3]=255;*/
    var img_ind=0;
    
    var xyinc=1/pixels2;
    var overinc = xyinc/oversample;
    var oversample2 = oversample*oversample;
    var xunit= -1 - xyinc; // these go from -1 to +1
    var yunit= -1 - xyinc;
    if (img_width>0)
      yunit=-img_height/pixels2;
    var xx=0;
    var yy=0;
    var z=0;
    var xlimit=pixels;
    if (img_width>0)
      xlimit=img_width;
    var ylimit=pixels;
    if (img_height>0)
      ylimit=img_height;
    
    for(var y=0; y<ylimit; y++)
    {
      yunit += xyinc;
      xunit= -1 - xyinc;
      yy = yunit*yunit;
      for(var x=0; x<xlimit; x++)
      {
         xunit += xyinc;
         xx = xunit*xunit;
         r2 = xx + yy;
         if (r2 > 1)
         {
           //outside unit circle
           pix[img_ind++]=0;//red*80;
           pix[img_ind++]=0;//green*80;
           pix[img_ind++]=0;//blue*80;
           pix[img_ind++]=255; // transparent         
           continue; 
         }
         save_xunit = xunit;
         save_yunit = yunit;
         rsum=0;
         gsum=0;
         bsum=0;
         for (overy=0; overy<oversample; overy++)
         {
           yy = yunit*yunit;
           xunit = save_xunit;
           for (overx=0; overx<oversample; overx++)
           {
             xx = xunit*xunit;
             r2 = xx + yy;
             r4 = r2*r2;
             z = c_z8*(6*(r4-r2)+1) + // z8 S.A.
                 c_tilt*xunit +          // xtilt
                c_def*(2*r2-1) +     // defocus
                c_astig*xx - c_astig*yy;          // astig
                 
             // z is already in waves  
             // z=0,1,2 should be black and z=0.5 1.5 etc should be brightest
             z = 2*Math.abs(.5 - (z-Math.floor(z))); // now ranges from 0 to 1 where 1 is brightest
             brightness=col(z);
             rsum+=brightness*red;
             gsum+=brightness*green;
             bsum+=brightness*blue;

             xunit += overinc;
           }
           yunit += overinc;
         }
         pix[img_ind++] = bytediv(rsum,oversample2);
         pix[img_ind++] = bytediv(gsum,oversample2);
         pix[img_ind++] = bytediv(bsum,oversample2);
         pix[img_ind++] = 255;
         
         xunit = save_xunit;
         yunit = save_yunit;
           
           
      }
    }
    ctx.putImageData(id,offsetX,offsetY);
    //t.innerHTML="time: "+ ((new Date()) - startTime).toFixed(0) + " ms";
    
    // now find highest slope - look only along the X axis and only check X slope
    var maxSlope=0;
    var maxSlopePixel=0;
    var slope=0;
    xunit = -1 - xyinc;
    for (var xp=0; xp<pixels; xp++)
    {
        xunit += xyinc;
        var x = xunit;
        if (Math.abs(xunit) > 1) continue; // only check within unit circle
        var x3 = x*x*x;
        
        slope = c_z8*6*(4*x3-2*x) + c_tilt + c_def*4*x + c_astig*2*x;
        
        if (Math.abs(slope) > Math.abs(maxSlope))
        {
            maxSlope = slope;
            maxSlopePixel=xp;
        }
    }
    
    // maxSlope is now in waves per unit circle radius
    maxSlope = maxSlope/(pixels/2);  // now in waves per pixel
    
    var ppf = Math.abs(1/maxSlope);

    /*
    var ts = document.getElementById('idslope');
    
    if (Math.sign(defocus) * Math.sign(astig) < 0 ||
       Math.abs(astig) > 2)
    {
        // hide "closest fringes" stuff - as the closest fringe is likely not along the X axis in these conditions
        ts.style.display="none";
        document.getElementById('idSlopeControl').style.display='none';
    }
    else
    {
        ts.style.display="";
        document.getElementById('idSlopeControl').style.display='';

        ts.innerHTML="Closest fringes: "+ppf.toFixed(2)+" pixels per fringe";
        
        if (ppf < 3 || ppf < pixels/360)
            ts.innerHTML="<font color='red'><b>"+ts.innerHTML+" (maybe add defocus?)</b></font>";
         
        if (ppf < pixels/360 && pixels > 720)
          ts.innerHTML += " (lowest I've ever done at this resolution: "+
            (pixels/360).toFixed(1);
            
        if (document.getElementById('chkShowSlope').checked)
        {
            // show a circle around the spot
            ctx.strokeStyle="rgb(150,150,150)";
            ctx.lineWidth=3;
            ctx.beginPath();
            ctx.arc(maxSlopePixel+4,4+pixels/2,pixels/30,0,Math.PI*2,true);//x, y, radius, startAngle, endAngle, counterclockwise)
            ctx.stroke();
        }
    }
    */
    return ppf;
}





function MPchange()
{
  get('idtxtVertPixels').value = Math.sqrt(get('idtxtMP').value*1000000/1.5);
  round('idtxtVertPixels', 0);
  update();
}

function vertPixChange()
{
  var vp=get('idtxtVertPixels').value;
  get('idtxtMP').value = (vp*vp*1.5/1000000).toFixed(1);
  update();
}


function vertPixFocus()
{
  get('idradVertPix').click();
}

function MPFocus()
{
  get('idradMegaPix').click();
}

function radMPclick(t)
{
  if (t.value == "mp")
  {
    get('idtxtMP').style.color='black';
    get('idLabelMP').style.color='black';
    get('idLabelMP2').style.color='black';

    get('idradVertPix').style.color='gray';
    get('idtxtVertPixels').style.color='gray';
    get('idLabelVertPix').style.color='gray';

    MPchange();
  }
  else
  {
    get('idtxtMP').style.color='gray';
    get('idLabelMP').style.color='gray';
    get('idLabelMP2').style.color='gray';

    get('idradVertPix').style.color='black';
    get('idtxtVertPixels').style.color='black';
    get('idLabelVertPix').style.color='black';
    update();
  }
}

function fnumfocus()
{
  get('idradfnum').click();
}

function flfocus()
{
  get('idradfl').click();
}

function fnumchange()
{
  $('#idStartBy').hide();
  get('idfltxt').value = get('idfnumtxt').value * get('idDiamtxt').value;
  round('idfltxt', radioPosition=="mm" ? 0 : 1);
  update();
}

function flchange()
{
  get('idfnumtxt').value = get('idfltxt').value / get('idDiamtxt').value;
  round('idfnumtxt', 2);
  update();
}


function get(id)
{
  return document.getElementById(id);
}

function round(id,decimals)
{
  var t=get(id);
  t.value=parseFloat(t.value).toFixed(decimals);
}

function unitclick(myRadio)
{
  // change all mm to inch or back
  var prev = radioPosition;
  radioPosition = myRadio.value;
  if (prev == radioPosition)
  {
    // no change
    return;
  }
  // switch over all units
  if (radioPosition == "mm")
    multiplier = 25.4;
  else
    multiplier = 1/25.4;
  get('idDiamtxt').value *= multiplier;
  round('idDiamtxt', radioPosition=="mm" ? 0 : 1);
  get('idfltxt').value *= multiplier;
  round('idfltxt', radioPosition=="mm" ? 0 : 1);




}
function radfclick(myRadF)
{
  $('#idStartBy').hide();
  // grey out unselected radio row
  if (myRadF.value == "fnum")
  {
    get('idfltxt').style.color='gray';
    get('idLabelFL').style.color='gray';
    get('idfnumtxt').style.color='black';
    get('idLabelFnum').style.color='black';
  }
  else
  {
    get('idfltxt').style.color='black';
    get('idLabelFL').style.color='black';
    get('idfnumtxt').style.color='gray';
    get('idLabelFnum').style.color='gray';
    
  }
}




function updateDiam()
{
  $('#idStartBy').hide();
  mirror_diameter = get('idDiamtxt').value;
  if (mirror_diameter == 0 || mirror_diameter=="")
    return;
  if (get('idradfnum').checked)
  {
    // recalculate focal length
    fnumchange();    // recalculate fnum
    flchange();
  }
  else
  {
    // recalculate fnum
    flchange();
  }
}

function recommend()
{
  $('#idtxtMP').val(14200000);     // D3100
  $('#idtxtVertPixels').val(3072); // D3100
  $('#idsensor').val(15.4);        // D3100
  vertPixFocus();

  $('#idLensFL').val("50");
  $('#idLensFnum').val("2");
  update();
  // max focal length such that any higher focal length will crop the image (no margin included) 
  max_focal_length = lensFL* mirrorFOV / camFOV;
  // minimum focal length such that we run out of pixels (no margin included)
  min_focal_length = lensFL*4/ppf;
  while (mirrorFOVdeg / camFOVdeg >= 1)
  {
    // ppf calculations not done because igram doesn't fit in FOV so start by shrinking lens
    $('#idLensFL').val($('#idLensFL').val()/2);
    update();
  }
  var sac = synth_apeture_cropping(50, 50/1.4, false);
  var sac_percent = sac/mirrorFOVmm*100;  
  
  if (min_focal_length < 34  && max_focal_length >55 && sac_percent > 150)
  {
    messagebox("Green cameras are the best choice but any of these will work well.");
    makeCameraRadios(1,3072,2);
    $('#idPopup2').fadeIn(200);
    $('#idPopup1').fadeOut(200);
    return;
  }
  
  min_pixels = 3072*min_focal_length/34;
  if (min_pixels>3072 && min_pixels <= 4000 && max_focal_length > 60 && sac_percent > 150)
  {
    messagebox("Green cameras are the best choice but any of these will work well.");
    makeCameraRadios(1,min_pixels,2);
    makeCameraRadios(1,3072,2);
    $('#idPopup2').fadeIn(200);
    $('#idPopup1').fadeOut(200);
    return;
  }
  
  if (max_focal_length <= 55)
  {
    messagebox("The f/# of your mirror is low enough that we need a wider angle view than typical to see your whole mirror with the camera. The 2 obvious solutions are to use a full frame camera (could be thousands of dollars) or a wider angle lens (also could be only $50 for say a 28mm or $1000 for something wider). Plus I'm not sure what other requirements there might be because this 'recommend a camera' code is very simple.  So I'm going to start you with a cropped camera (the Nikon D3200) and you need to click the choose a lens button and if the choices don't make sense then maybe try a full frame camera.");
  } else
  {
    messagebox("Your mirror is unusual enough that my first choice cameras with a 50mm lens won't work. I'm going to start you with the Nikon D3200 which is often a good choice but try hitting the 'choose a lens' and see what it suggests.");
  }
  console.log("minp ",min_pixels+" min_fl: "+min_focal_length+" max_fl: "+max_focal_length+" sac_percent: "+sac_percent);
  chose_cam(findCam("D3200"),true);
  $('#idPopup1').fadeOut(200);
  

/*
  messagebox("Nikon gives you the best features for the money.  Choose Nikon and then choose any green camera.  The green cameras are the cheapest that have the needed features and are excellent for testing most mirrors. In some rare cases (e.g. 30 inch F/3), while choosing your lens, it may be recommended to increase the camera resolution. For 90% of mirrors any green camera plus a 50mm lens will work. If that is true for you then the next step would be to look at prices of used cameras on ebay.  Camera bodies are about $200.  50mm lenses are about $50. Check that the camera you are thinking of buying will work with a nice margin (no red or yellow text once you choose the hardware).");*/
}
function nikon()
{
  makeCameraRadios(1);
  $('#idPopup2').fadeIn(200);
  $('#idPopup1').fadeOut(200);
}
function canon()
{
  makeCameraRadios(2);
  $('#idPopup2').fadeIn(200);
  $('#idPopup1').fadeOut(200);
}
function sony()
{
  choose_camera_close();
  messagebox("Sony cameras mostly don't meet the needed specs or if they do they are 3X the cost of Nikon and 2X the cost of Canons.  I don't recommend Sony but there are some good options if you already own one.  If you have a type-A lens mount body (versus type-E) there are good 50mm Minolta type-a 50mm lenses. You'll want at least a 10mp body (24mp for difficult mirrors like 30 inch f/3) and live view with zoom (digitally see what camera sees live for focusing and seeing igrams as the sensor sees them).  Unfortunately you need to manually enter the sensor size and megapixels.");  
  $('#idCamDescription').text("Sony");
  $('#idCamDescription').css("color","black");  
  $('#idBtnChooseCamera').css("color","black");
  $('#idBtnChooseCamera').text("click to change camera");
}
function cell()
{
  choose_camera_close();
  messagebox("Cell phones will not work or might just barely work. They are too hard to align and have too small a hole to let the igram into even if the phone lens is touching the splitter. You would also need an extra small splitter (15mm is much too big) and a smaller than typical laser beam, and a shorter focal length than usual diverger (no idea where to get divergers < 6mm focal length). You'll need a special app that gives you precise focus control (I don't think that exists on apple phones and 'tap to focus' will not work for igrams). I filled in the numbers for an iphone 11 but it doesn't take into account that it will crop the hell out of most igrams even when the phone is touching the splitter.",other_continue);
  $('#idCamDescription').text("iphone 11");
  $('#idCamDescription').css("color","black");
  $('#idBtnChooseCamera').css("color","black");
  $('#idBtnChooseCamera').text("click to change camera");
  
  $('#idsensor').val("10");
  $('#idtxtMP').val("12");
  $('#idLensFL').val("26");
  $('#idLensFnum').val("1.8");
  $('#idtxtVertPixels').val("3040");
  MPFocus();
  
}
function rasp()
{
  choose_camera_close();
  messagebox("This feature isn't filled out yet so for now I'll recommend you avoid raspi because the lenses tend to be very cheap (<$20 new) and I don't trust that the lenses have low enough distortion for good igram results. Except maybe the LN06 so I filled in the data for ras pi hq with LN06.",other_continue);
  $('#idsensor').val("4.712");
  $('#idtxtMP').val("12.3");
  $('#idLensFL').val("16");
  $('#idLensFnum').val("1.4");
  $('#idtxtVertPixels').val("3040");
  vertPixFocus();
  $('#idCamDescription').text("Ras Pi with LN06 lens");
  $('#idCamDescription').css("color","blue");
  $('#idBtnChooseCamera').css("color","black");
  $('#idBtnChooseCamera').text("click to change camera");
update();
}
function webcam()
{
  choose_camera_close();
  messagebox("This feature isn't filled out yet so for now I'll recommend you avoid webcams but you can just manually fill in the camera info.",other_continue);
  $('#idCamDescription').text("webcam");
  $('#idCamDescription').css("color","black");  
  $('#idBtnChooseCamera').css("color","black");
  $('#idBtnChooseCamera').text("click to change camera");

}
function other_continue()
{
  $('#idBtnChooseCamera').css("color","black");
  $('#idBtnChooseCamera').text("click to change camera");
}
function other()
{
  choose_camera_close();
  messagebox("Okay then please just fill in the camera and lens information.",other_continue);
  $('#idCamDescription').text("other");
  $('#idCamDescription').css("color","black");  
}

var msgbox_callback;
function messagebox(txt,callback,bHTML)
{
  msgbox_callback=callback;
  if (bHTML)
    $('#idSpanMsgBox').html(txt);
  else
    $('#idSpanMsgBox').text(txt);
  $('#idMsgBox').fadeIn(200);
  $('#idDarken').show();
}
function close_msgbox()
{
  $('#idMsgBox').fadeOut(200);
  if (msgbox_callback)
    msgbox_callback();
  $('#idDarken').hide();
}

function search()
{
  // search through all cameras that have higher or equal resolution to value left of search button
  makeCameraRadios("*",$('#idtxtVertPixels').val());
  $('#idPopup2').fadeIn(200);
  $('#idPopup1').fadeOut(200);

}

function close_dialog2()
{
  $('#idPopup2').fadeOut(200);
  $('#idDarken').hide();
}

$('#idBtnChooseCamera').click(choose_camera);
$('#idBtnChooseLens').click(choose_lens);
$('#idClose1').click(choose_camera_close);

$('#idBtnRec').click(recommend);
$('#idBtnNik').click(nikon);
$('#idBtnCan').click(canon);
$('#idBtnSony').click(sony);
$('#idBtnCel').click(cell);
$('#idBtnRas').click(rasp);
$('#idBtnWeb').click(webcam);
$('#idBtnOth').click(other);
$('#idBtnSearch').click(search);

$('#idCloseMB').click(close_msgbox);
$('#idStartBy').show();




</script>

</body>


